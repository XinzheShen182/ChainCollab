{
  "package": "package main",
  "import": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n)\n",
  "contract_definition": "type SmartContract struct {\n\tcontractapi.Contract\n}\n",
  "fix_part": "type ContractInstance struct {\n\t// Incremental ID\n\tInstanceID string `json:\"InstanceID\"`\n\t// global Memory\n\tInstanceStateMemory StateMemory `json:\"stateMemory\"`\n\t// map type from string to Message、Gateway、ActionEvent\n\tInstanceElements map[string]interface{} `json:\"InstanceElements\"`\n\t// state of the instance\n\tInstanceState InstanceState `json:\"InstanceState\"`\n}\n\ntype ElementState int\n\nconst (\n\tDISABLED = iota\n\tENABLED\n\tWAITINGFORCONFIRMATION\n\tCOMPLETED\n)\n\ntype InstanceState int\n\nconst (\n\tTOBEREGISTERED = iota\n\tREADY\n)\n\ntype Participant struct {\n\tMSP          string            `json:\"msp\"`\n\tAttributes   map[string]string `json:\"attributes\"`\n\tIsMulti      bool              `json:\"isMulti\"`\n\tMultiMaximum int               `json:\"multiMaximum\"`\n\tMultiMinimum int               `json:\"multiMinimum\"`\n\n\tX509 string `json:\"x509\"`\n}\n\ntype Message struct {\n\tMessageID            string       `json:\"messageID\"`\n\tSendParticipantID    string       `json:\"sendMspID\"`\n\tReceiveParticipantID string       `json:\"receiveMspID\"`\n\tFireflyTranID        string       `json:\"fireflyTranID\"`\n\tMsgState             ElementState `json:\"msgState\"`\n\tFormat               string       `json:\"format\"`\n}\n\ntype Gateway struct {\n\tGatewayID    string       `json:\"gatewayID\"`\n\tGatewayState ElementState `json:\"gatewayState\"`\n}\n\ntype ActionEvent struct {\n\tEventID    string       `json:\"eventID\"`\n\tEventState ElementState `json:\"eventState\"`\n}\n\nfunc (cc *SmartContract) CreateParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string, msp string, attributes map[string]string, IsMulti bool, MultiMaximum int, MultiMinimum int) (*Participant, error) {\n\tstub := ctx.GetStub()\n\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建参与者对象\n\tinstance.InstanceElements[participantID] = &Participant{\n\t\tMSP:          msp,\n\t\tAttributes:   attributes,\n\t\tIsMulti:      IsMulti,\n\t\tMultiMaximum: MultiMaximum,\n\t\tMultiMinimum: MultiMinimum,\n\t}\n\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将参与者对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\treturnParticipant, ok := instance.InstanceElements[participantID].(*Participant)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Participant\")\n\t}\n\n\treturn returnParticipant, nil\n\n}\n\nfunc (cc *SmartContract) CreateMessage(ctx contractapi.TransactionContextInterface, instanceID string, messageID string, sendParticipantID string, receiveParticipantID string, fireflyTranID string, msgState ElementState, format string) (*Message, error) {\n\tstub := ctx.GetStub()\n\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// read from the existing instance\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建消息对象\n\tinstance.InstanceElements[messageID] = &Message{\n\t\tMessageID:            messageID,\n\t\tSendParticipantID:    sendParticipantID,\n\t\tReceiveParticipantID: receiveParticipantID,\n\t\tFireflyTranID:        fireflyTranID,\n\t\tMsgState:             msgState,\n\t\tFormat:               format,\n\t}\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将消息对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\treturnMessage, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Message\")\n\t}\n\n\treturn returnMessage, nil\n}\n\nfunc (cc *SmartContract) CreateGateway(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string, gatewayState ElementState) (*Gateway, error) {\n\tstub := ctx.GetStub()\n\n\t// 检查是否存在具有相同ID的记录\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建网关对象\n\tinstance.InstanceElements[gatewayID] = &Gateway{\n\t\tGatewayID:    gatewayID,\n\t\tGatewayState: gatewayState,\n\t}\n\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将网关对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\treturnGateway, ok := instance.InstanceElements[gatewayID].(*Gateway)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Gateway\")\n\t}\n\n\treturn returnGateway, nil\n}\n\nfunc (cc *SmartContract) CreateActionEvent(ctx contractapi.TransactionContextInterface, instanceID string, eventID string, eventState ElementState) (*ActionEvent, error) {\n\tstub := ctx.GetStub()\n\n\t// 检查是否存在具有相同ID的记录\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建事件对象\n\tinstance.InstanceElements[eventID] = &ActionEvent{\n\t\tEventID:    eventID,\n\t\tEventState: eventState,\n\t}\n\n\treturnEvent, ok := instance.InstanceElements[eventID].(*ActionEvent)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为ActionEvent\")\n\t}\n\n\treturn returnEvent, nil\n\n}\n\n// Read function\nfunc (c *SmartContract) ReadMsg(ctx contractapi.TransactionContextInterface, instanceID string, messageID string) (*Message, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tmsg, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn msg, nil\n}\n\nfunc (c *SmartContract) ReadGtw(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string) (*Gateway, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tgtw, ok := instance.InstanceElements[gatewayID].(*Gateway)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn gtw, nil\n\n}\n\nfunc (c *SmartContract) ReadEvent(ctx contractapi.TransactionContextInterface, instanceID string, eventID string) (*ActionEvent, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tactionEvent, ok := instance.InstanceElements[eventID].(*ActionEvent)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Event %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn actionEvent, nil\n\n}\n\n// Change State  function\nfunc (c *SmartContract) ChangeMsgState(ctx contractapi.TransactionContextInterface, instanceID string, messageID string, msgState ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tmsg, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tmsg.MsgState = msgState\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeMsgFireflyTranID(ctx contractapi.TransactionContextInterface, instanceID string, messageID string, fireflyTranID string) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tmsg, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tmsg.FireflyTranID = fireflyTranID\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeGtwState(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string, gtwState ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tgtw, ok := instance.InstanceElements[gatewayID].(*Gateway)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tgtw.GatewayState = gtwState\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeEventState(ctx contractapi.TransactionContextInterface, instanceID string, eventID string, eventState ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tactionEvent, ok := instance.InstanceElements[eventID].(*ActionEvent)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Event %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tactionEvent.EventState = eventState\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\n//get all message\n\nfunc (cc *SmartContract) GetAllMessages(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Message, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar messages []*Message\n\tfor _, element := range instance.InstanceElements {\n\t\tmsg, ok := element.(*Message)\n\t\tif ok {\n\t\t\tmessages = append(messages, msg)\n\t\t}\n\t}\n\n\treturn messages, nil\n}\n\nfunc (cc *SmartContract) GetAllGateways(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Gateway, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar gateways []*Gateway\n\tfor _, element := range instance.InstanceElements {\n\t\tgtw, ok := element.(*Gateway)\n\t\tif ok {\n\t\t\tgateways = append(gateways, gtw)\n\t\t}\n\t}\n\n\treturn gateways, nil\n}\n\nfunc (cc *SmartContract) GetAllActionEvents(ctx contractapi.TransactionContextInterface, instanceID string) ([]*ActionEvent, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar actionEvents []*ActionEvent\n\tfor _, element := range instance.InstanceElements {\n\t\tevent, ok := element.(*ActionEvent)\n\t\tif ok {\n\t\t\tactionEvents = append(actionEvents, event)\n\t\t}\n\t}\n\n\treturn actionEvents, nil\n\n}\n\nfunc (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &instance.InstanceStateMemory, nil\n\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string, globalVariable *StateMemory) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tinstance.InstanceStateMemory = *globalVariable\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (cc *SmartContract) ReadParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string) (*Participant, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tparticipant, ok := instance.InstanceElements[participantID].(*Participant)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Participant %s does not exist\", participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn participant, nil\n\n}\n\nfunc (cc *SmartContract) check_msp(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string) bool {\n\t// Read the target participant's msp\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tmspID, err := ctx.GetClientIdentity().GetMSPID()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mspID == targetParticipant.MSP\n}\n\nfunc (cc *SmartContract) check_attribute(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string, attributeName string) bool {\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ctx.GetClientIdentity().AssertAttributeValue(attributeName, targetParticipant.Attributes[attributeName]) != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) check_participant(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string) bool {\n\t// Read the target participant's msp\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\t// check MSP if msp!=''\n\tif targetParticipant.MSP != \"\" && cc.check_msp(ctx, instanceID, target_participant) == false {\n\t\treturn false\n\t}\n\n\t// check all attributes\n\tfor key, _ := range targetParticipant.Attributes {\n\t\tif cc.check_attribute(ctx, instanceID, target_participant, key) == false {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {\n\tstub := ctx.GetStub()\n\n\t// isInited in state\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to get isInited: %v\", err)\n\t}\n\tif isInitedBytes != nil {\n\t\terrorMessage := \"Chaincode has already been initialized\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}\n\n\tstub.PutState(\"currentInstanceId\", []byte(\"0\"))\n\n\tstub.PutState(\"isInited\", []byte(\"true\"))\n\n\tstub.SetEvent(\"initContractEvent\", []byte(\"Contract has been initialized successfully\"))\n\treturn nil\n}\n",
  "InitFuncFrame": "func (cc *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {{\n\tstub := ctx.GetStub()\n\n\t// isInited in state\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"Failed to get isInited: %v\", err)\n\t}}\n\tif isInitedBytes != nil {{\n\t\terrorMessage := \"Chaincode has already been initialized\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n{}\n\tstub.PutState(\"isInited\", []byte(\"true\"))\n\n\tstub.SetEvent(\"initContractEvent\", []byte(\"Contract has been initialized successfully\"))\n\treturn nil\n}}\n",
  "InitStart": "\tcc.CreateActionEvent(ctx, \"{}\", ENABLED)\n",
  "InitEnd": "\tcc.CreateActionEvent(ctx, \"{}\", DISABLED)",
  "InitMessage": "\tcc.CreateMessage(ctx, \"{}\", \"{}\", \"{}\", \"\", DISABLED, `{}`)",
  "InitGateway": "\tcc.CreateGateway(ctx, \"{}\", DISABLED)\n",
  "ChangeEventState": "    cc.ChangeEventState(ctx, instanceID, \"{event}\", {state})",
  "ChangeMsgState": "    cc.ChangeMsgState(ctx, instanceID, \"{message}\", {state})",
  "ChangeGtwState": "    cc.ChangeGtwState(ctx, instanceID, \"{gateway}\", {state})",
  "StartEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tactionEvent, err := cc.ReadEvent(ctx, instanceID, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif actionEvent.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", actionEvent.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, instanceID, \"{event}\", COMPLETED)\n\tstub.SetEvent(\"{event}\", []byte(\"Contract has been started successfully\"))\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\treturn nil\n}}",
  "MessageSendFuncFrame": "func (cc *SmartContract) {message}_Send(ctx contractapi.TransactionContextInterface, instanceID string, fireflyTranID string {more_parameters}) error {{\n\tstub := ctx.GetStub()\n\tmsg, err := cc.ReadMsg(ctx, instanceID, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif cc.check_participant(ctx, instanceID, msg.SendParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Message state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgFireflyTranID(ctx, instanceID, fireflyTranID, msg.MessageID)\n\tcc.ChangeMsgState(ctx, instanceID, msg.MessageID, WAITINGFORCONFIRMATION)\n\t{put_more_parameters}\n\tstub.SetEvent(\"{message}\", []byte(\"Message is waiting for confirmation\"))\n\n\t{after_all_hook}\n\treturn nil\n}}",
  "MessageCompleteFuncFrame": "func (cc *SmartContract) {message}_Complete(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tmsg, err := cc.ReadMsg(ctx, instanceID, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif cc.check_participant(ctx, instanceID, msg.ReceiveParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != WAITINGFORCONFIRMATION {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgState(ctx, instanceID, msg.MessageID, COMPLETED)\n\tstub.SetEvent(\"{message}\", []byte(\"Message has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\n\t{after_all_hook}\n\treturn nil\n}}",
  "EndEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tevent, err := cc.ReadEvent(ctx, instanceID, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif event.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", event.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, instanceID, event.EventID, COMPLETED) \n\tstub.SetEvent(\"{event}\", []byte(\"EndEvent has been done\"))\n\t{after_all_hook}\n\treturn nil\n}}",
  "ParallelGatewaySplitFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, ENABLED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\n{change_next_state_code}\n\n\treturn nil\n}}",
  "ParallelGatewayMergeFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\treturn nil\n}}",
  "EventBasedGatewayFuncFrame": "func (cc *SmartContract) {event_based_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{ \n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{event_based_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{event_based_gateway}\", []byte(\"EventbasedGateway has been done\"))\n\n {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n    return nil\n}}",
  "ExclusiveGatewaySplitFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n}}",
  "ExclusiveGatewayMergeFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n}}",
  "CheckMessageState": "func() bool {{ msg, err := cc.ReadMsg(ctx, instanceID, \"{message}\"); return err == nil && msg.MsgState == {state} }}()",
  "CheckGtwState": "func() bool {{ gtw, err := cc.ReadGtw(ctx, instanceID, \"{gateway}\"); return err == nil && gtw.GatewayState == {state} }}()",
  "CheckEventState": "func() bool {{ event, err := cc.ReadEvent(ctx, \"{event}\"); return err == nil && event.EventState == {state} }}()",
  "ConditionToDo": "if {condition} {{\n\t{todo}\n}}",
  "StateMemoryDefinitionFrame": "type StateMemory struct {{\n    {fields}\n}}",
  "StateReadAndSetFunc": "func (cc *SmartContract) ReadState(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tstateJSON, err := ctx.GetStub().GetState(\"currentMemory\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif stateJSON == nil {\n\t\t// return a empty stateMemory\n\t\treturn &StateMemory{}, nil\n\t}\n\n\tvar stateMemory StateMemory\n\terr = json.Unmarshal(stateJSON, &stateMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &stateMemory, nil\n}\n\nfunc (cc *SmartContract) PutState(ctx contractapi.TransactionContextInterface, stateName string, stateValue interface{}) error {\n\tstub := ctx.GetStub()\n\tcurrentMemory, err := cc.ReadState(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tval := reflect.ValueOf(currentMemory)\n\tif val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {\n\t\treturn errors.New(\"currentMemory is not a struct pointer\")\n\t}\n\tfield := val.Elem().FieldByName(stateName)\n\tif !field.IsValid() {\n\t\treturn errors.New(\"field does not exist\")\n\t}\n\tif !field.CanSet() {\n\t\treturn errors.New(\"field cannot be set\")\n\t}\n\t// 根据字段类型将stateValue转换为合适的类型\n\tswitch field.Interface().(type) {\n\tcase string:\n\t\tstringValue, ok := stateValue.(string)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a string\")\n\t\t}\n\t\tfield.SetString(stringValue)\n\tcase int:\n\t\tintValue, ok := stateValue.(int)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not an int\")\n\t\t}\n\t\tfield.SetInt(int64(intValue))\n\tcase float64:\n\t\tfloatValue, ok := stateValue.(float64)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a float64\")\n\t\t}\n\t\tfield.SetFloat(floatValue)\n\tcase bool:\n\t\tboolValue, ok := stateValue.(bool)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a bool\")\n\t\t}\n\t\tfield.SetBool(boolValue)\n\t// 添加其他类型的处理...\n\tdefault:\n\t\treturn errors.New(\"unsupported field type\")\n\t}\n\n\tcurrentMemoryJSON, err := json.Marshal(currentMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(\"currentMemory\", currentMemoryJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}",
  "PutStateFuncFrame": "    cc.PutState(ctx, instanceID, \"{name}\", {value})",
  "ReadStateFuncFrame": "    {stateName}:=currentMemory.{stateName}\n",
  "ReadCurrentMemoryCode": "    currentMemory,err := cc.ReadState(ctx)\n    if err != nil {\n        return err\n    }\n",
  "ReadAndSetGloablVariable": "func (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\treturn nil, fmt.Errorf(\"The instance %s does not exist\", instanceID)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstateMemory, ok := instance.StateMemory.(*StateMemory)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"The instance %s has no valid StateMemory\", instanceID)\n\t}\n\n\treturn stateMemory, nil\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string, globalVariable *StateMemory) error {\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\treturn fmt.Errorf(\"The instance %s does not exist\", instanceID)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinstance.StateMemory = globalVariable\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn stub.PutState(instanceID, instanceJson)\n\n}",
  "SetGlobalVariableFuncFrame": "\tglobalMemory,readGloabolError := cc.ReadGlobalVariable(ctx, instanceID)\n\tif readGloabolError != nil {{\n\t\tfmt.Println(readGloabolError.Error())\n\t\treturn readGloabolError\n\t}}\n\tglobalMemory.{name} = {value}\n\tsetGloabolErrror :=cc.SetGlobalVariable(ctx, instanceID, globalMemory)\n\tif setGloabolErrror != nil {{\n\t\tfmt.Println(setGloabolErrror.Error())\n\t\treturn setGloabolErrror\n\t}}",
  "ReadGlobalVariable": "\tcurrentMemory, err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n",
  "InitParticipant": "\tcc.CreateParticipant(ctx, instanceID, \"{participant_id}\", \"{participant_msp}\", map[string]string{{{participant_attrs}}})",
  "CreateInstanceFuncFrame": "func (cc *SmartContract) CreateInstance(ctx contractapi.TransactionContextInterface, InitParameters string) (string, error) {\n\tstub := ctx.GetStub()\n\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}\n\n\tif isInitedBytes != nil {\n\t\treturn \"\", fmt.Errorf(\"The instance has been initialized.\")\n\t}\n\n\tvar isInited bool\n\terr = json.Unmarshal(isInitedBytes, &isInited)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}\n\n\tif !isInited {\n\t\treturn \"\", fmt.Errorf(\"The instance has not been initialized.\")\n\t}\n\n\t// get the instanceID\n\n\tvar instanceID string\n\tinstanceIDString, err := stub.GetState(\"currentInstanceID\")\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}\n\n\terr = json.Unmarshal(instanceIDString, &instanceID)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}\n\n\t// Create the instance with the data from the InitParameters\n\tvar initParameters InitParameters\n\terr = json.Unmarshal([]byte(InitParameters), &initParameters)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}\n\n\tinstance := Instance{\n\t\tInstanceID:          instanceID,\n\t\tInstanceStateMemory: &InstanceStateMemory{},\n\t\tInstanceElements:    make(map[string]*InstanceElement),\n\t}\n\n\t// this part is hard coded in generate time\n\t// Create Message\n\t// Create Participant\n\t// Create Event\n\t// Create Gateway\n\t// And so on\n\t{\n\t\tcreate_elements_code\n\t}\n\n\t// Save the instance\n\tinstanceBytes, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to marshal. %s\", err.Error())\n\t}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}\n\n\t// Update the currentInstanceID\n\n\tinstanceIDInt, err := strconv.Atoi(instanceID)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to convert instanceID to int. %s\", err.Error())\n\t}\n\n\tinstanceIDInt++\n\tinstanceID = strconv.Itoa(instanceIDInt)\n\n\tinstanceIDBytes, err := json.Marshal(instanceID)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to marshal instanceID. %s\", err.Error())\n\t}\n\n\terr = stub.PutState(\"currentInstanceID\", instanceIDBytes)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}\n\n\treturn instanceID, nil\n\n}",
  "InitParametersTypeDefFrame": "type InitParameters struct {{\n    {fields=fields}\n}}",
  "InvokeChaincodeFunc": "func (cc *SmartContract) Invoke_Other_chaincode(ctx contractapi.TransactionContextInterface, functionName string, args1 string, args2 string) (string, error) {\n\tstub := ctx.GetStub()\n\n\t// 将args字符串切片转换为字节切片的二维切片\n\tvar _args [][]byte = make([][]byte, 4)\n\t_args[0] = []byte(functionName)\n\t_args[1] = []byte(args1)\n\t_args[3] = []byte(args2)\n\n\trule := `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\t<definitions xmlns=\"http://www.omg.org/spec/DMN/20151101/dmn.xsd\" xmlns:camunda=\"http://camunda.org/schema/1.0/dmn\" id=\"dish\" name=\"Dish\" namespace=\"test-drd-2\">\n\t  <decision id=\"dish-decision\" name=\"Dish Decision\">\n\t\t<informationRequirement>\n\t\t  <requiredDecision href=\"#season\" />\n\t\t</informationRequirement>\n\t\t<informationRequirement>\n\t\t  <requiredDecision href=\"#guestCount\" />\n\t\t</informationRequirement>\n\t\t<decisionTable id=\"dishDecisionTable\">\n\t\t  <input id=\"seasonInput\" label=\"Season\">\n\t\t\t<inputExpression id=\"seasonInputExpression\" typeRef=\"string\">\n\t\t\t  <text>season</text>\n\t\t\t</inputExpression>\n\t\t  </input>\n\t\t  <input id=\"guestCountInput\" label=\"How many guests\">\n\t\t\t<inputExpression id=\"guestCountInputExpression\" typeRef=\"integer\">\n\t\t\t  <text>guestCount</text>\n\t\t\t</inputExpression>\n\t\t  </input>\n\t\t  <output id=\"output1\" label=\"Dish\" name=\"desiredDish\" typeRef=\"string\" />\n\t\t  <rule id=\"row-495762709-1\">\n\t\t\t<inputEntry id=\"UnaryTests_1nxcsjr\">\n\t\t\t  <text><![CDATA[\"Winter\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<inputEntry id=\"UnaryTests_1r9yorj\">\n\t\t\t  <text><![CDATA[<=8]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1mtwzqz\">\n\t\t\t  <text><![CDATA[\"Spareribs\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-495762709-2\">\n\t\t\t<inputEntry id=\"UnaryTests_1lxjbif\">\n\t\t\t  <text><![CDATA[\"Winter\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<inputEntry id=\"UnaryTests_0nhiedb\">\n\t\t\t  <text><![CDATA[>8]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1h30r12\">\n\t\t\t  <text><![CDATA[\"Pasta\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-495762709-3\">\n\t\t\t<inputEntry id=\"UnaryTests_0ifgmfm\">\n\t\t\t  <text><![CDATA[\"Summer\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<inputEntry id=\"UnaryTests_12cib9m\">\n\t\t\t  <text><![CDATA[>10]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_0wgaegy\">\n\t\t\t  <text><![CDATA[\"Light salad\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-495762709-7\">\n\t\t\t<inputEntry id=\"UnaryTests_0ozm9s7\">\n\t\t\t  <text><![CDATA[\"Summer\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<inputEntry id=\"UnaryTests_0sesgov\">\n\t\t\t  <text><![CDATA[<=10]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1dvc5x3\">\n\t\t\t  <text><![CDATA[\"Beans salad\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-445981423-3\">\n\t\t\t<inputEntry id=\"UnaryTests_1er0je1\">\n\t\t\t  <text><![CDATA[\"Spring\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<inputEntry id=\"UnaryTests_1uzqner\">\n\t\t\t  <text><![CDATA[<10]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1pxy4g1\">\n\t\t\t  <text><![CDATA[\"Stew\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-445981423-4\">\n\t\t\t<inputEntry id=\"UnaryTests_06or48g\">\n\t\t\t  <text><![CDATA[\"Spring\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<inputEntry id=\"UnaryTests_0wa71sy\">\n\t\t\t  <text><![CDATA[>=10]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_09ggol9\">\n\t\t\t  <text><![CDATA[\"Steak\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t</decisionTable>\n\t  </decision>\n\t  <decision id=\"season\" name=\"Season decision\">\n\t\t<decisionTable id=\"seasonDecisionTable\">\n\t\t  <input id=\"temperatureInput\" label=\"Weather in Celsius\">\n\t\t\t<inputExpression id=\"temperatureInputExpression\" typeRef=\"integer\">\n\t\t\t  <text>temperature</text>\n\t\t\t</inputExpression>\n\t\t  </input>\n\t\t  <output id=\"seasonOutput\" label=\"season\" name=\"season\" typeRef=\"string\" />\n\t\t  <rule id=\"row-495762709-5\">\n\t\t\t<inputEntry id=\"UnaryTests_1fd0eqo\">\n\t\t\t  <text><![CDATA[>30]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_0l98klb\">\n\t\t\t  <text><![CDATA[\"Summer\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-495762709-6\">\n\t\t\t<inputEntry id=\"UnaryTests_1nz6at2\">\n\t\t\t  <text><![CDATA[<10]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_08moy1k\">\n\t\t\t  <text><![CDATA[\"Winter\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-445981423-2\">\n\t\t\t<inputEntry id=\"UnaryTests_1a0imxy\">\n\t\t\t  <text>[10..30]</text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1poftw4\">\n\t\t\t  <text><![CDATA[\"Spring\"]]></text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t</decisionTable>\n\t  </decision>\n\t  <decision id=\"guestCount\" name=\"Guest Count\">\n\t\t<decisionTable id=\"guestCountDecisionTable\">\n\t\t  <input id=\"typeOfDayInput\" label=\"Type of day\">\n\t\t\t<inputExpression id=\"typeOfDayInputExpression\" typeRef=\"string\">\n\t\t\t  <text>dayType</text>\n\t\t\t</inputExpression>\n\t\t  </input>\n\t\t  <output id=\"guestCountOutput\" label=\"Guest count\" name=\"guestCount\" typeRef=\"integer\" />\n\t\t  <rule id=\"row-495762709-8\">\n\t\t\t<inputEntry id=\"UnaryTests_0l72u8n\">\n\t\t\t  <text><![CDATA[\"WeekDay\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_0wuwqaz\">\n\t\t\t  <text>4</text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-495762709-9\">\n\t\t\t<inputEntry id=\"UnaryTests_03a73o9\">\n\t\t\t  <text><![CDATA[\"Holiday\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1whn119\">\n\t\t\t  <text>10</text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t  <rule id=\"row-495762709-10\">\n\t\t\t<inputEntry id=\"UnaryTests_12tygwt\">\n\t\t\t  <text><![CDATA[\"Weekend\"]]></text>\n\t\t\t</inputEntry>\n\t\t\t<outputEntry id=\"LiteralExpression_1b5k9t8\">\n\t\t\t  <text>15</text>\n\t\t\t</outputEntry>\n\t\t  </rule>\n\t\t</decisionTable>\n\t  </decision>\n\t</definitions>`\n\n\t_args[2] = []byte(rule)\n\n\t// 调用其他链码\n\tresponse := stub.InvokeChaincode(\"asset:v1\", _args, \"default\")\n\n\tif response.Status != shim.OK {\n\t\treturn \"\", fmt.Errorf(\"failed to invoke chaincode. Response status: %d. Response message: %s\", response.Status, response.Message)\n\t}\n\n\tfmt.Print(\"response.Payload: \")\n\tfmt.Println(string(response.Payload))\n\n\treturn \"\", nil\n}"
}