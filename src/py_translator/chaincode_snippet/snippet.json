{
  "EndEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tevent, err := cc.ReadEvent(ctx, instanceID, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif event.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", event.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, instanceID, event.EventID, COMPLETED) \n\tstub.SetEvent(\"{event}\", []byte(\"EndEvent has been done\"))\n\t{after_all_hook}\n\treturn nil\n}}",
  "package": "package chaincode",
  "import": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"reflect\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"github.com/hyperledger/fabric-chaincode-go/shim\"\n\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n)\n",
  "contract_definition": "type SmartContract struct {\n\tcontractapi.Contract\n}\n",
  "fix_part": "type ContractInstance struct {\n\t// Incremental ID\n\tInstanceID string `json:\"InstanceID\"`\n\t// global Memory\n\tInstanceStateMemory StateMemory `json:\"stateMemory\"`\n\t// map type from string to Message、Gateway、ActionEvent\n\tInstanceElements map[string]interface{} `json:\"InstanceElements\"`\n\t// state of the instance\n\tInstanceState InstanceState `json:\"InstanceState\"`\n}\n\ntype ElementState int\n\nconst (\n\tDISABLED = iota\n\tENABLED\n\tWAITINGFORCONFIRMATION // means wait continue in BusinessRule\n\tCOMPLETED\n)\n\ntype InstanceState int\n\n// const (\n// \tTOBEREGISTERED = iota\n// \tREADY\n// )\n\ntype Participant struct {\n\tMSP          string            `json:\"msp\"`\n\tAttributes   map[string]string `json:\"attributes\"`\n\tIsMulti      bool              `json:\"isMulti\"`\n\tMultiMaximum int               `json:\"multiMaximum\"`\n\tMultiMinimum int               `json:\"multiMinimum\"`\n\n\tX509 string `json:\"x509\"`\n}\n\ntype Message struct {\n\tMessageID            string       `json:\"messageID\"`\n\tSendParticipantID    string       `json:\"sendMspID\"`\n\tReceiveParticipantID string       `json:\"receiveMspID\"`\n\tFireflyTranID        string       `json:\"fireflyTranID\"`\n\tMsgState             ElementState `json:\"msgState\"`\n\tFormat               string       `json:\"format\"`\n}\n\ntype Gateway struct {\n\tGatewayID    string       `json:\"gatewayID\"`\n\tGatewayState ElementState `json:\"gatewayState\"`\n}\n\ntype ActionEvent struct {\n\tEventID    string       `json:\"eventID\"`\n\tEventState ElementState `json:\"eventState\"`\n}\n\ntype BusinessRule struct {\n\tCID          string            `json:\"cid\"`\n\tHash         string            `json:\"hash\"`\n\tDecisionID   string            `json:\"decisionId\"`\n\tParamMapping map[string]string `json:\"mapping\"`\n\tState        ElementState      `json:\"state\"`\n}\n\nfunc (cc *SmartContract) CreateBusinessRule(ctx contractapi.TransactionContextInterface, InstanceID string, BusinessRuleID string, CID string, DMNContent string, DecisionId string, ParamMapping map[string]string) (*BusinessRule, error) {\n\tstub := ctx.GetStub()\n\n\texistingData, err := stub.GetState(InstanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", InstanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\tHash, err := cc.hashXML(ctx, DMNContent)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\t// 创建业务规则对象\n\tinstance.InstanceElements[BusinessRuleID] = &BusinessRule{\n\t\tCID:          CID,\n\t\tHash:         Hash,\n\t\tDecisionID:   \"\",\n\t\tParamMapping: ParamMapping,\n\t\tState:        DISABLED,\n\t}\n\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将业务规则对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(InstanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\teventPayload := map[string]string{\n\t\t\"InstanceID\": InstanceID,\n\t\t\"ID\":         BusinessRuleID,\n\t\t\"DMNContent\": DMNContent,\n\t}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}\n\n\terr = ctx.GetStub().SetEvent(\"DMNContentCreated\", eventPayloadAsBytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to set event: %v\", err)\n\t}\n\n\treturnBusinessRule, ok := instance.InstanceElements[BusinessRuleID].(*BusinessRule)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为BusinessRule\")\n\t}\n\n\treturn returnBusinessRule, nil\n}\n\nfunc (cc *SmartContract) CreateParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string, msp string, attributes map[string]string, IsMulti bool, MultiMaximum int, MultiMinimum int) (*Participant, error) {\n\tstub := ctx.GetStub()\n\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建参与者对象\n\tinstance.InstanceElements[participantID] = &Participant{\n\t\tMSP:          msp,\n\t\tAttributes:   attributes,\n\t\tIsMulti:      IsMulti,\n\t\tMultiMaximum: MultiMaximum,\n\t\tMultiMinimum: MultiMinimum,\n\t}\n\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将参与者对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\treturnParticipant, ok := instance.InstanceElements[participantID].(*Participant)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Participant\")\n\t}\n\n\treturn returnParticipant, nil\n\n}\n\nfunc (cc *SmartContract) CreateMessage(ctx contractapi.TransactionContextInterface, instanceID string, messageID string, sendParticipantID string, receiveParticipantID string, fireflyTranID string, msgState ElementState, format string) (*Message, error) {\n\tstub := ctx.GetStub()\n\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// read from the existing instance\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建消息对象\n\tinstance.InstanceElements[messageID] = &Message{\n\t\tMessageID:            messageID,\n\t\tSendParticipantID:    sendParticipantID,\n\t\tReceiveParticipantID: receiveParticipantID,\n\t\tFireflyTranID:        fireflyTranID,\n\t\tMsgState:             msgState,\n\t\tFormat:               format,\n\t}\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将消息对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\treturnMessage, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Message\")\n\t}\n\n\treturn returnMessage, nil\n}\n\nfunc (cc *SmartContract) CreateGateway(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string, gatewayState ElementState) (*Gateway, error) {\n\tstub := ctx.GetStub()\n\n\t// 检查是否存在具有相同ID的记录\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建网关对象\n\tinstance.InstanceElements[gatewayID] = &Gateway{\n\t\tGatewayID:    gatewayID,\n\t\tGatewayState: gatewayState,\n\t}\n\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"序列化实例数据时出错: %v\", err)\n\t}\n\t// 将网关对象序列化为JSON字符串并保存在状态数据库中\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"保存实例数据时出错: %v\", err)\n\t}\n\n\treturnGateway, ok := instance.InstanceElements[gatewayID].(*Gateway)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为Gateway\")\n\t}\n\n\treturn returnGateway, nil\n}\n\nfunc (cc *SmartContract) CreateActionEvent(ctx contractapi.TransactionContextInterface, instanceID string, eventID string, eventState ElementState) (*ActionEvent, error) {\n\tstub := ctx.GetStub()\n\n\t// 检查是否存在具有相同ID的记录\n\texistingData, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"获取状态数据时出错: %v\", err)\n\t}\n\tif existingData == nil {\n\t\treturn nil, fmt.Errorf(\"实例 %s 不存在\", instanceID)\n\t}\n\n\t// 从现有实例中读取\n\tvar instance ContractInstance\n\terr = json.Unmarshal(existingData, &instance)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"反序列化实例数据时出错: %v\", err)\n\t}\n\n\t// 创建事件对象\n\tinstance.InstanceElements[eventID] = &ActionEvent{\n\t\tEventID:    eventID,\n\t\tEventState: eventState,\n\t}\n\n\treturnEvent, ok := instance.InstanceElements[eventID].(*ActionEvent)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为ActionEvent\")\n\t}\n\n\treturn returnEvent, nil\n\n}\n\n// Read function\nfunc (c *SmartContract) ReadMsg(ctx contractapi.TransactionContextInterface, instanceID string, messageID string) (*Message, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tmsg, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn msg, nil\n}\n\nfunc (c *SmartContract) ReadGtw(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string) (*Gateway, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tgtw, ok := instance.InstanceElements[gatewayID].(*Gateway)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn gtw, nil\n\n}\n\nfunc (c *SmartContract) ReadEvent(ctx contractapi.TransactionContextInterface, instanceID string, eventID string) (*ActionEvent, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tactionEvent, ok := instance.InstanceElements[eventID].(*ActionEvent)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Event %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn actionEvent, nil\n\n}\n\n// Change State  function\nfunc (c *SmartContract) ChangeMsgState(ctx contractapi.TransactionContextInterface, instanceID string, messageID string, msgState ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tmsg, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tmsg.MsgState = msgState\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeMsgFireflyTranID(ctx contractapi.TransactionContextInterface, instanceID string, messageID string, fireflyTranID string) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tmsg, ok := instance.InstanceElements[messageID].(*Message)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tmsg.FireflyTranID = fireflyTranID\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeGtwState(ctx contractapi.TransactionContextInterface, instanceID string, gatewayID string, gtwState ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tgtw, ok := instance.InstanceElements[gatewayID].(*Gateway)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Gateway %s does not exist\", gatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tgtw.GatewayState = gtwState\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (c *SmartContract) ChangeEventState(ctx contractapi.TransactionContextInterface, instanceID string, eventID string, eventState ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tactionEvent, ok := instance.InstanceElements[eventID].(*ActionEvent)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Event %s does not exist\", eventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tactionEvent.EventState = eventState\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (cc *SmartContract) ChangeBusinessRuleState(ctx contractapi.TransactionContextInterface, instanceID string, BusinessRuleID string, state ElementState) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tbusinessRule, ok := instance.InstanceElements[BusinessRuleID].(*BusinessRule)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"BusinessRule %s does not exist\", BusinessRuleID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tbusinessRule.State = state\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\n//get all message\n\nfunc (cc *SmartContract) GetAllMessages(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Message, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar messages []*Message\n\tfor _, element := range instance.InstanceElements {\n\t\tmsg, ok := element.(*Message)\n\t\tif ok {\n\t\t\tmessages = append(messages, msg)\n\t\t}\n\t}\n\n\treturn messages, nil\n}\n\nfunc (cc *SmartContract) GetAllGateways(ctx contractapi.TransactionContextInterface, instanceID string) ([]*Gateway, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar gateways []*Gateway\n\tfor _, element := range instance.InstanceElements {\n\t\tgtw, ok := element.(*Gateway)\n\t\tif ok {\n\t\t\tgateways = append(gateways, gtw)\n\t\t}\n\t}\n\n\treturn gateways, nil\n}\n\nfunc (cc *SmartContract) GetAllActionEvents(ctx contractapi.TransactionContextInterface, instanceID string) ([]*ActionEvent, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tvar actionEvents []*ActionEvent\n\tfor _, element := range instance.InstanceElements {\n\t\tevent, ok := element.(*ActionEvent)\n\t\tif ok {\n\t\t\tactionEvents = append(actionEvents, event)\n\t\t}\n\t}\n\n\treturn actionEvents, nil\n\n}\n\nfunc (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &instance.InstanceStateMemory, nil\n\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string, globalVariable *StateMemory) error {\n\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tinstance.InstanceStateMemory = *globalVariable\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (cc *SmartContract) ReadBusinessRule(ctx contractapi.TransactionContextInterface, instanceID string, BusinessRuleID string) (*BusinessRule, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tbusinessRule, ok := instance.InstanceElements[BusinessRuleID].(*BusinessRule)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"BusinessRule %s does not exist\", BusinessRuleID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn businessRule, nil\n}\n\nfunc (cc *SmartContract) ReadParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string) (*Participant, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tparticipant, ok := instance.InstanceElements[participantID].(*Participant)\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Participant %s does not exist\", participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn participant, nil\n\n}\n\nfunc (cc *SmartContract) WriteParticipant(ctx contractapi.TransactionContextInterface, instanceID string, participantID string, participant *Participant) error {\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\tinstance.InstanceElements[participantID] = participant\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(instanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n\n}\n\nfunc (cc *SmartContract) check_msp(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string) bool {\n\t// Read the target participant's msp\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tmspID, err := ctx.GetClientIdentity().GetMSPID()\n\tif err != nil {\n\t\treturn false\n\t}\n\treturn mspID == targetParticipant.MSP\n}\n\nfunc (cc *SmartContract) check_attribute(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string, attributeName string) bool {\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\tif ctx.GetClientIdentity().AssertAttributeValue(attributeName, targetParticipant.Attributes[attributeName]) != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) check_participant(ctx contractapi.TransactionContextInterface, instanceID string, target_participant string) bool {\n\t// Read the target participant's msp\n\ttargetParticipant, err := cc.ReadParticipant(ctx, instanceID, target_participant)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tif !targetParticipant.IsMulti {\n\t\t// check X509 = MSPID + @ + ID\n\t\tmspID, _ := ctx.GetClientIdentity().GetMSPID()\n\t\tpid, _ := ctx.GetClientIdentity().GetID()\n\t\tif targetParticipant.X509 == pid+\"@\"+mspID {\n\t\t\treturn true\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// check MSP if msp!=''\n\tif targetParticipant.MSP != \"\" && cc.check_msp(ctx, instanceID, target_participant) == false {\n\t\treturn false\n\t}\n\n\t// check all attributes\n\tfor key, _ := range targetParticipant.Attributes {\n\t\tif cc.check_attribute(ctx, instanceID, target_participant, key) == false {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {\n\tstub := ctx.GetStub()\n\n\t// isInited in state\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to get isInited: %v\", err)\n\t}\n\tif isInitedBytes != nil {\n\t\terrorMessage := \"Chaincode has already been initialized\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}\n\n\tstub.PutState(\"currentInstanceId\", []byte(\"0\"))\n\n\tstub.PutState(\"isInited\", []byte(\"true\"))\n\n\tstub.SetEvent(\"initContractEvent\", []byte(\"Contract has been initialized successfully\"))\n\treturn nil\n}\n\nfunc (s *SmartContract) hashXML(ctx contractapi.TransactionContextInterface, xmlString string) (string, error) {\n\t// Calculate SHA-256 hash\n\thash := sha256.New()\n\thash.Write([]byte(xmlString))\n\thashInBytes := hash.Sum(nil)\n\thashString := hex.EncodeToString(hashInBytes)\n\tfmt.Print(hashString)\n\treturn hashString, nil\n}\n\n",
  "InitStartFrame": "\tcc.CreateActionEvent(ctx, instanceID, \"{start_event}\", ENABLED)\n",
  "InitEndFrame": "\tcc.CreateActionEvent(ctx, instanceID, \"{end_event}\", DISABLED)\n",
  "InitMessageFrame": "\tcc.CreateMessage(ctx, instanceID, \"{message}\", \"{sender}\", \"{receiver}\", \"\", DISABLED, `{format}`)",
  "InitGatewayFrame": "\tcc.CreateGateway(ctx, instanceID, \"{gateway}\", DISABLED)\n",
  "ChangeEventStateFrame": "    cc.ChangeEventState(ctx, instanceID, \"{event}\", {state})",
  "ChangeMsgStateFrame": "    cc.ChangeMsgState(ctx, instanceID, \"{message}\", {state})",
  "ChangeGtwStateFrame": "    cc.ChangeGtwState(ctx, instanceID, \"{gateway}\", {state})",
  "StartEventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\n\tactionEvent, err := cc.ReadEvent(ctx, instanceID, \"{event}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif actionEvent.EventState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", actionEvent.EventID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeEventState(ctx, instanceID, \"{event}\", COMPLETED)\n\tstub.SetEvent(\"{event}\", []byte(\"Contract has been started successfully\"))\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\treturn nil\n}}",
  "MessageSendFuncFrame": "func (cc *SmartContract) {message}_Send(ctx contractapi.TransactionContextInterface, instanceID string, fireflyTranID string {more_parameters}) error {{\n\tstub := ctx.GetStub()\n\tmsg, err := cc.ReadMsg(ctx, instanceID, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t//\n\tif cc.check_participant(ctx, instanceID, msg.SendParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Message state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgFireflyTranID(ctx, instanceID, fireflyTranID, msg.MessageID)\n\tcc.ChangeMsgState(ctx, instanceID, msg.MessageID, WAITINGFORCONFIRMATION)\n\t{put_more_parameters}\n\tstub.SetEvent(\"{message}\", []byte(\"Message is waiting for confirmation\"))\n\n\t{after_all_hook}\n\treturn nil\n}}",
  "MessageCompleteFuncFrame": "func (cc *SmartContract) {message}_Complete(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tmsg, err := cc.ReadMsg(ctx, instanceID, \"{message}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif cc.check_participant(ctx, instanceID, msg.ReceiveParticipantID) == false{{\n\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", msg.SendParticipantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tif msg.MsgState != WAITINGFORCONFIRMATION {{\n\t\terrorMessage := fmt.Sprintf(\"Event state %s is not allowed\", msg.MessageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeMsgState(ctx, instanceID, msg.MessageID, COMPLETED)\n\tstub.SetEvent(\"{message}\", []byte(\"Message has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\n\t{after_all_hook}\n\treturn nil\n}}",
  "ParallelGatewaySplitFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, ENABLED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\n\t{change_next_state_code}\n\n\treturn nil\n}}",
  "ParallelGatewayMergeFuncFrame": "func (cc *SmartContract) {parallel_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{parallel_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{parallel_gateway}\", []byte(\"Gateway has been done\"))\n\n\t{pre_activate_next_hook}\n\t{change_next_state_code}\n\t{after_all_hook}\n\treturn nil\n}}",
  "EventBasedGatewayFuncFrame": "func (cc *SmartContract) {event_based_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{ \n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{event_based_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{event_based_gateway}\", []byte(\"EventbasedGateway has been done\"))\n\n \t{pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n    return nil\n}}",
  "ExclusiveGatewaySplitFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n}}",
  "ExclusiveGatewayMergeFuncFrame": "func (cc *SmartContract) {exclusive_gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tgtw, err := cc.ReadGtw(ctx, instanceID, \"{exclusive_gateway}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tif gtw.GatewayState != ENABLED {{\n\t\terrorMessage := fmt.Sprintf(\"Gateway state %s is not allowed\", gtw.GatewayID)\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\tcc.ChangeGtwState(ctx, instanceID, gtw.GatewayID, COMPLETED)\n\tstub.SetEvent(\"{exclusive_gateway}\", []byte(\"ExclusiveGateway has been done\"))\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n}}",
  "CheckMessageStateFrame": "func() bool {{ msg, err := cc.ReadMsg(ctx, instanceID, \"{message}\"); return err == nil && msg.MsgState == {state} }}()",
  "CheckGtwStateFrame": "func() bool {{ gtw, err := cc.ReadGtw(ctx, instanceID, \"{gateway}\"); return err == nil && gtw.GatewayState == {state} }}()",
  "CheckEventStateFrame": "func() bool {{ event, err := cc.ReadEvent(ctx, \"{event}\"); return err == nil && event.EventState == {state} }}()",
  "ConditionToDoFrame": "if {condition} {{\n\t{todo}\n}}",
  "StateMemoryDefinitionFrame": "type StateMemory struct {{\n    {fields}\n}}",
  "StateReadAndSetFunc": "func (cc *SmartContract) ReadState(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tstateJSON, err := ctx.GetStub().GetState(\"currentMemory\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif stateJSON == nil {\n\t\t// return a empty stateMemory\n\t\treturn &StateMemory{}, nil\n\t}\n\n\tvar stateMemory StateMemory\n\terr = json.Unmarshal(stateJSON, &stateMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &stateMemory, nil\n}\n\nfunc (cc *SmartContract) PutState(ctx contractapi.TransactionContextInterface, stateName string, stateValue interface{}) error {\n\tstub := ctx.GetStub()\n\tcurrentMemory, err := cc.ReadState(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tval := reflect.ValueOf(currentMemory)\n\tif val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {\n\t\treturn errors.New(\"currentMemory is not a struct pointer\")\n\t}\n\tfield := val.Elem().FieldByName(stateName)\n\tif !field.IsValid() {\n\t\treturn errors.New(\"field does not exist\")\n\t}\n\tif !field.CanSet() {\n\t\treturn errors.New(\"field cannot be set\")\n\t}\n\t// 根据字段类型将stateValue转换为合适的类型\n\tswitch field.Interface().(type) {\n\tcase string:\n\t\tstringValue, ok := stateValue.(string)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a string\")\n\t\t}\n\t\tfield.SetString(stringValue)\n\tcase int:\n\t\tintValue, ok := stateValue.(int)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not an int\")\n\t\t}\n\t\tfield.SetInt(int64(intValue))\n\tcase float64:\n\t\tfloatValue, ok := stateValue.(float64)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a float64\")\n\t\t}\n\t\tfield.SetFloat(floatValue)\n\tcase bool:\n\t\tboolValue, ok := stateValue.(bool)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a bool\")\n\t\t}\n\t\tfield.SetBool(boolValue)\n\t// 添加其他类型的处理...\n\tdefault:\n\t\treturn errors.New(\"unsupported field type\")\n\t}\n\n\tcurrentMemoryJSON, err := json.Marshal(currentMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(\"currentMemory\", currentMemoryJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}",
  "PutStateFuncFrame": "    cc.PutState(ctx, instanceID, \"{name}\", {value})",
  "ReadStateFuncFrame": "    {stateName}:=currentMemory.{stateName}\n",
  "ReadCurrentMemoryCode": "    currentMemory,err := cc.ReadState(ctx)\n    if err != nil {\n        return err\n    }\n",
  "ReadAndSetGloablVariable": "func (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\treturn nil, fmt.Errorf(\"The instance %s does not exist\", instanceID)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstateMemory, ok := instance.StateMemory.(*StateMemory)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"The instance %s has no valid StateMemory\", instanceID)\n\t}\n\n\treturn stateMemory, nil\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string, globalVariable *StateMemory) error {\n\tstub := ctx.GetStub()\n\n\tinstanceJson, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif instanceJson == nil {\n\t\treturn fmt.Errorf(\"The instance %s does not exist\", instanceID)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tinstance.StateMemory = globalVariable\n\n\tinstanceJson, err = json.Marshal(instance)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn stub.PutState(instanceID, instanceJson)\n\n}",
  "SetGlobalVariableFuncFrame": "\tglobalMemory,readGloabolError := cc.ReadGlobalVariable(ctx, instanceID)\n\tif readGloabolError != nil {{\n\t\tfmt.Println(readGloabolError.Error())\n\t\treturn readGloabolError\n\t}}\n\tglobalMemory.{name} = {value}\n\tsetGloabolErrror :=cc.SetGlobalVariable(ctx, instanceID, globalMemory)\n\tif setGloabolErrror != nil {{\n\t\tfmt.Println(setGloabolErrror.Error())\n\t\treturn setGloabolErrror\n\t}}",
  "ReadGlobalVariable": "\tcurrentMemory, err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n",
  "InitParticipantFrame": "\tcc.CreateParticipant(ctx, instanceID, \"{participant_id}\", initParameters.{participant_id}.MSP, initParameters.{participant_id}.Attributes, {is_multi}, {multi_maximum}, {multi_minimum})",
  "CreateInstanceFuncFrame": "func (cc *SmartContract) CreateInstance(ctx contractapi.TransactionContextInterface, initParametersBytes string) (string, error) {{\n\tstub := ctx.GetStub()\n\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}}\n\n\tif isInitedBytes != nil {{\n\t\treturn \"\", fmt.Errorf(\"The instance has been initialized.\")\n\t}}\n\n\tvar isInited bool\n\terr = json.Unmarshal(isInitedBytes, &isInited)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}}\n\n\tif !isInited {{\n\t\treturn \"\", fmt.Errorf(\"The instance has not been initialized.\")\n\t}}\n\n\t// get the instanceID\n\n\tvar instanceID string\n\tinstanceIDString, err := stub.GetState(\"currentInstanceID\")\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}}\n\n\terr = json.Unmarshal(instanceIDString, &instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}}\n\n\t// Create the instance with the data from the InitParameters\n\tvar initParameters InitParameters\n\terr = json.Unmarshal([]byte(initParametersBytes), &initParameters)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}}\n\n\tinstance := ContractInstance{{\n\t\tInstanceID:          instanceID,\n\t\tInstanceStateMemory: StateMemory{{}},\n\t\tInstanceElements:    make(map[string]interface{{}}),\n\t}}\n\n\t// Save the instance\n\tinstanceBytes, err := json.Marshal(instance)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to marshal. %s\", err.Error())\n\t}}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}}\n\n\t// Update the currentInstanceID\n\n\t{create_elements_code}\n\n\tinstanceIDInt, err := strconv.Atoi(instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to convert instanceID to int. %s\", err.Error())\n\t}}\n\n\tinstanceIDInt++\n\tinstanceID = strconv.Itoa(instanceIDInt)\n\n\tinstanceIDBytes, err := json.Marshal(instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to marshal instanceID. %s\", err.Error())\n\t}}\n\n\terr = stub.PutState(\"currentInstanceID\", instanceIDBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}}\n\n\treturn instanceID, nil\n\n}}",
  "InitParametersTypeDefFrame": "type InitParameters struct {{\n    {fields}\n}}",
  "InvokeChaincodeFunc": "func (cc *SmartContract) Invoke_Other_chaincode(ctx contractapi.TransactionContextInterface, chaincodeName string, channel string, _args [][]byte) (string, error) {\n\tstub := ctx.GetStub()\n\tresponse := stub.InvokeChaincode(chaincodeName, _args, channel)\n\n\tif response.Status != shim.OK {\n\t\treturn \"\", fmt.Errorf(\"failed to invoke chaincode. Response status: %d. Response message: %s\", response.Status, response.Message)\n\t}\n\n\tfmt.Print(\"response.Payload: \")\n\tfmt.Println(string(response.Payload))\n\n\treturn string(response.Payload), nil\n}",
  "RegisterFunc": "func (cc *SmartContract) RegisterParticipant(ctx contractapi.TransactionContextInterface, instanceID string, targetParticipantID string) error {\n\t{\n\t\t// check if the participant is single\n\t\tvar targetParticipant Participant\n\t\tparticipant, _ := cc.ReadParticipant(ctx, instanceID, targetParticipantID)\n\t\tif participant.IsMulti {\n\t\t\t{\n\t\t\t\treturn fmt.Errorf(\"The participant is not multi\")\n\t\t\t}\n\t\t}\n\n\t\t// check ACL\n\n\t\tif !cc.check_participant(ctx, instanceID, targetParticipantID) {\n\t\t\treturn fmt.Errorf(\"The participant is not allowed to be registered\")\n\t\t}\n\n\t\t// Read the identity of invoker ,and binding it's identity to the participant\n\n\t\t// Get the identity of the invoker\n\t\tinvokerIdentity, err := ctx.GetClientIdentity().GetID()\n\t\tmspIndentity, err := ctx.GetClientIdentity().GetMSPID()\n\n\t\tX509 := invokerIdentity + \"@\" + mspIndentity\n\n\t\t// save the identity to the participant\n\t\ttargetParticipant.X509 = X509\n\n\t\t// save the participant\n\t\terr = cc.WriteParticipant(ctx, instanceID, targetParticipantID, &targetParticipant)\n\t\tif err != nil {\n\t\t\t{\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}",
  "CheckRegisterFunc": "func (cc *SmartContract) CheckRegister(ctx contractapi.TransactionContextInterface, instanceID string) (bool, error) {\n\tstub := ctx.GetStub()\n\n\t// Check if the instance has been registered\n\tinstanceBytes, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceBytes, &instance)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}\n\n\tif instance.InstanceState == READY {\n\t\treturn true, nil\n\t}\n\n\t// set State depend on Participant with IsMulti=true\n\n\tfor element, value := range instance.InstanceElements {\n\t\tparticipant, ok := value.(*Participant)\n\t\tif ok {\n\t\t\tif !participant.IsMulti && participant.X509 == \"\" {\n\t\t\t\treturn false, fmt.Errorf(\"The participant %s is not registered.\", element)\n\t\t\t}\n\t\t}\n\t}\n\n\t// set State depend on Participant with IsMulti=false\n\tinstance.InstanceState = READY\n\tinstanceBytes, err = json.Marshal(instance)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to marshal. %s\", err.Error())\n\t}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}\n\n\treturn true, nil\n}",
  "InitBusinessRuleFrame": "\tcc.CreateBusinessRule(ctx, instanceID, \"{business_rule}\", initParameters.{business_rule}.CID, initParameters.{business_rule}_Content, initParameters.{business_rule}.DecisionID, initParameters.{business_rule}.ParamMapping)",
  "BusinessRuleFuncFrame": "func (cc *SmartContract) {business_rule}(ctx contractapi.TransactionContextInterface, instanceID string, DmnID string) error {{\n\n\t// Read Business Info\n\tbusinessRule, err := cc.ReadBusinessRule(ctx, instanceID, \"{business_rule}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t// Check the BusinessRule State\n\tif businessRule.State != ENABLED {{\n\t\treturn fmt.Errorf(\"The BusinessRule is not ENABLED\")\n\t}}\n\n\teventPayload := map[string]string{{\n\t\t\"ID\":         DmnID,\n\t\t\"InstanceID\": instanceID,\n\t\t\"Func\":\t   \"{business_rule}_Continue\",\n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"DMNContentRequired\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\n\tcc.ChangeBusinessRuleState(ctx, instanceID, \"{business_rule}\", WAITINGFORCONFIRMATION)\n\n\treturn nil\n}}",
  "BusinessRuleContinueFuncFrame": "func (cc *SmartContract) {business_rule}_Continue(ctx contractapi.TransactionContextInterface, instanceID string, ContentOfDmn string) error {{\n\t// Read Business Info\n\tbusinessRule, err := cc.ReadBusinessRule(ctx, instanceID, \"{business_rule}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t// Check the BusinessRule State\n\tif businessRule.State != WAITINGFORCONFIRMATION {{\n\t\treturn fmt.Errorf(\"The BusinessRule is not Actived\")\n\t}}\n\n\t// check the hash\n\thashString, _ := cc.hashXML(ctx, ContentOfDmn)\n\tif hashString != businessRule.Hash {{\n\t\treturn fmt.Errorf(\"The hash is not matched\")\n\t}}\n\n\t// Combine the Parameters\n\t_args := make([][]byte, 4)\n\t_args[0] = []byte(\"createRecord\")\n\t// input in json format\n\tParamMapping := businessRule.ParamMapping\n\trealParamMapping := make(map[string]interface{{}})\n\tglobalVariable, _err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif _err != nil {{\n\t\treturn _err\n\t}}\n\n\tfor key, value := range ParamMapping {{\n\t\tfield := reflect.ValueOf(globalVariable).FieldByName(value)\n\t\tif !field.IsValid() {{\n\t\t\treturn fmt.Errorf(\"The field %s is not valid\", value)\n\t\t}}\n\t\trealParamMapping[key] = field.Interface()\t\t\n\t}}\n\tvar inputJsonBytes []byte\n\tinputJsonBytes, err= json.Marshal(realParamMapping)\n\tif err != nil {{\n\t\treturn err\n\t}}\n\t_args[1] = inputJsonBytes\n\n\t// DMN Content\n\t_args[2] = []byte(ContentOfDmn)\n\n\t// decisionId\n\t_args[3] = []byte(businessRule.DecisionID)\n\n\t// Invoke DMN Engine Chaincode\n\tvar resJson string\n\tresJson, err=cc.Invoke_Other_chaincode(ctx, \"asset:v1\",\"default\", _args)\n\n\t// Set the Result\n\tvar res map[string]interface{{}}\n\terr = json.Unmarshal([]byte(resJson), &res)\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tfor key, value := range res {{\n\t\tfield := reflect.ValueOf(globalVariable).FieldByName(key)\n\t\tif !field.IsValid() {{\n\t\t\treturn fmt.Errorf(\"The field %s is not valid\", key)\n\t\t}}\n\t\tfield.Set(reflect.ValueOf(value))\n\t}}\n\n\t// Update the GlobalVariable\n\terr = cc.SetGlobalVariable(ctx, instanceID, globalVariable)\n\n\t// Change the BusinessRule State\n\tcc.ChangeBusinessRuleState(ctx, instanceID, \"{business_rule}\", COMPLETED)\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\treturn nil\n\n}}"
}