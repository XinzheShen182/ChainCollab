{
  "package": "package chaincode\n",
  "importFrame": "import (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"reflect\"\n\t\"crypto/sha256\"\n\t\"strings\"\n\t\"encoding/hex\"\n\t\"github.com/hyperledger/fabric-chaincode-go/shim\"\n\t\"github.com/hyperledger/fabric-contract-api-go/contractapi\"\n\t\n\t{extra_imports}\n)\n",
  "OracleImport": "\"IBC/Oracle/oracle\"",
  "StateChartsImport": "\"IBC/StateCharts/stateCharts\"",
  "contract_definition": "type SmartContract struct {\n\tcontractapi.Contract\n}\n",
  "fix_part": "type ContractInstance struct {\n\t// Incremental ID\n\tInstanceID string `json:\"InstanceID\"`\n\t// global Memory\n\tInstanceStateMemory StateMemory `json:\"stateMemory\"`\n\t// map type from string to Message、Gateway、ActionEvent\n\tInstanceMessages          map[string]*CollectiveMessage     `json:\"InstanceMessages\"`\n\tInstanceBusinessRules     map[string]*BusinessRule          `json:\"InstanceBusinessRule\"`\n\tInstanceParticipants      map[string]*CollectiveParticipant `json:\"InstanceParticipants\"`\n\tInstanceChoreographyTasks map[string]*ChoreographyTask      `json:\"InstanceChoreographyTasks\"`\n\t// state of the instance\n\tCurrentState            string `json:\"CurrentState\"`\n\tStateMachineDescription string `json:\"StateMachineDescription\"`\n\tAdditionalContent       string `json:\"AdditionalContent\"`\n}\n\ntype CollectiveParticipant struct {\n\tParticipantID string                 `json:\"PartcipantID\"`\n\tParticipants  map[string]Participant `json:\"Participants\"`\n\tIsMulti       bool                   `json:\"IsMulti\"`\n\tIsLocked      bool                   `json:\"IsLocked\"`\n\tMultiMaximum  int                    `json:\"MultiMaximum\"`\n\tMultiMinimum  int                    `json:\"MultiMinimum\"`\n\tAttributes    map[string]string      `json:\"Attributes\"`\n}\n\ntype Participant struct {\n\t// ID To Sync With OuterEngine\n\tParticipantID string `json:\"ParticipantID\"`\n\tMSP           string `json:\"MSP\"`\n\tIsMulti       bool   `json:\"IsMulti\"`\n\tX509          string `json:\"X509\"`\n}\n\ntype ParticipantForInit struct {\n\tPartcipantID string            `json:\"PartcipantID\"`\n\tIsMulti      bool              `json:\"IsMulti\"`\n\tMultiMaximum int               `json:\"MultiMaximum\"`\n\tMultiMinimum int               `json:\"MultiMinimum\"`\n\tAttributes   map[string]string `json:\"Attributes\"`\n\tMSP          string            `json:\"MSP\"`\n\tX509         string            `json:\"X509\"`\n}\n\ntype ChoreographyTask struct {\n\tChoreographyTaskID   string `json:\"ChoreographyTaskID\"`\n\tIsMulti              bool   `json:\"IsMulti\"`\n\tMultiType            string `json:\"MultiType\"`\n\tInitMessageCount     int    `json:\"InitMessageCount\"`\n\tResponseMessageCount int    `json:\"ResponseMessageCount\"`\n\tInitMessage          string `json:\"InitMessage\"`\n\tResponseMessage      string `json:\"ResponseMessage\"`\n}\n\ntype CollectiveMessage struct {\n\tChoreographyTaskID    string                        `json:\"ChoreographyTaskID\"`\n\tMessageID             string                        `json:\"MessageID\"`\n\tMessages              map[string]map[string]Message `json:\"Messages\"`\n\tIsMulti               bool                          `json:\"IsMulti\"`\n\tMessageConfirmedCount int                           `json:\"MessageConfirmedCount\"`\n\tSendParticipantID     string                        `json:\"SendMspID\"`\n\tReceiveParticipantID  string                        `json:\"ReceiveMspID\"`\n\tFormat                string                        `json:\"Format\"`\n}\n\ntype Message struct {\n\tMessageID             string `json:\"MessageID\"`\n\tSendParticipantKey    string `json:\"SendParticipantKey\"`\n\tReceiveParticipantKey string `json:\"ReceiveParticipantKey\"`\n\tFireflyTranID         string `json:\"FireflyTranID\"`\n}\n\ntype BusinessRule struct {\n\tBusinessRuleID string            `json:\"BusinessRuleID\"`\n\tHash           string            `json:\"Hash\"`\n\tDecisionID     string            `json:\"DecisionID\"`\n\tParamMapping   map[string]string `json:\"ParamMapping\"`\n}\n\nfunc (cc *SmartContract) CreateBusinessRule(ctx contractapi.TransactionContextInterface, instance *ContractInstance, BusinessRuleID string, DMNContent string, DecisionID string, ParamMapping map[string]string) (*BusinessRule, error) {\n\n\tHash, err := cc.hashXML(ctx, DMNContent)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\tinstance.InstanceBusinessRules[BusinessRuleID] = &BusinessRule{\n\t\tBusinessRuleID: BusinessRuleID,\n\t\tHash:           Hash,\n\t\tDecisionID:     DecisionID,\n\t\tParamMapping:   ParamMapping,\n\t}\n\n\treturnBusinessRule, ok := instance.InstanceBusinessRules[BusinessRuleID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"无法将实例元素转换为BusinessRule\")\n\t}\n\n\treturn returnBusinessRule, nil\n}\n\nfunc (cc *SmartContract) CreateParticipant(ctx contractapi.TransactionContextInterface, instance *ContractInstance, participantID string, msp string, attributes map[string]string, x509 string, IsMulti bool, MultiMaximum int, MultiMinimum int) (*CollectiveParticipant, error) {\n\tcollectiveParticipant := &CollectiveParticipant{\n\t\tParticipantID: participantID,\n\t\tParticipants:  make(map[string]Participant), // 初始化 Participants 映射\n\t\tIsMulti:       IsMulti,\n\t\tIsLocked:      false,\n\t\tMultiMaximum:  MultiMaximum,\n\t\tMultiMinimum:  MultiMinimum,\n\t\tAttributes:    attributes,\n\t}\n\n\tif !IsMulti {\n\t\tparticipant := Participant{\n\t\t\tParticipantID: participantID,\n\t\t\tMSP:           msp,\n\t\t\tIsMulti:       IsMulti,\n\t\t\tX509:          x509,\n\t\t}\n\t\tcollectiveParticipant.Participants[participantID] = participant\n\t}\n\n\tinstance.InstanceParticipants[participantID] = collectiveParticipant\n\n\treturn collectiveParticipant, nil\n}\n\nfunc (cc *SmartContract) CreateChoreographyTask(\n\tctx contractapi.TransactionContextInterface,\n\tinstance *ContractInstance,\n\tchoreographyTaskID string,\n\tisMulti bool,\n\tmultiType string,\n\tinitMessage string,\n\tresponseMessage string,\n) (*ChoreographyTask, error) {\n\tchoreographyTask := &ChoreographyTask{\n\t\tChoreographyTaskID:   choreographyTaskID,\n\t\tIsMulti:              isMulti,\n\t\tMultiType:            multiType,\n\t\tInitMessageCount:     0,\n\t\tResponseMessageCount: 0,\n\t\tInitMessage:          initMessage,\n\t\tResponseMessage:      responseMessage,\n\t}\n\n\tinstance.InstanceChoreographyTasks[choreographyTaskID] = choreographyTask\n\n\treturn choreographyTask, nil\n}\n\n// TODO： Method To Register Participant in CollectiveParticipant\n\nfunc (cc *SmartContract) CreateMessage(\n\tctx contractapi.TransactionContextInterface,\n\tinstance *ContractInstance,\n\tmessageID string,\n\tsendParticipantID string,\n\treceiveParticipantID string,\n\tfireflyTranID string,\n\tformat string,\n\tIsMulti bool,\n\tchoreographyTaskID string,\n) (*CollectiveMessage, error) {\n\tcollectiveMessage := &CollectiveMessage{\n\t\tChoreographyTaskID:    choreographyTaskID,\n\t\tMessageID:             messageID,\n\t\tMessages:              make(map[string]map[string]Message), // 初始化 Messages 映射\n\t\tIsMulti:               IsMulti,\n\t\tMessageConfirmedCount: 0,\n\t\tSendParticipantID:     sendParticipantID,\n\t\tReceiveParticipantID:  receiveParticipantID,\n\t\tFormat:                format,\n\t}\n\n\tif !IsMulti {\n\t\tcollectiveMessage.Messages[\"nonMulti\"] = make(map[string]Message)\n\t\tmessage := Message{\n\t\t\tMessageID:             fmt.Sprintf(\"%s\", messageID),\n\t\t\tSendParticipantKey:    fmt.Sprintf(\"%s_0\", sendParticipantID),\n\t\t\tReceiveParticipantKey: fmt.Sprintf(\"%s_0\", receiveParticipantID),\n\t\t\tFireflyTranID:         fireflyTranID,\n\t\t}\n\t\tcollectiveMessage.Messages[\"nonMulti\"][\"nonMulti\"] = message\n\t}\n\n\tinstance.InstanceMessages[messageID] = collectiveMessage\n\n\treturn collectiveMessage, nil\n}\n\nfunc (cc *SmartContract) GetInstance(ctx contractapi.TransactionContextInterface, instanceID string) (*ContractInstance, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &instance, nil\n}\n\nfunc (cc *SmartContract) SetInstance(ctx contractapi.TransactionContextInterface, instance *ContractInstance) error {\n\tinstanceJson, err := json.Marshal(instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = ctx.GetStub().PutState(instance.InstanceID, instanceJson)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (c *SmartContract) ChangeMsgFireflyTranID(ctx contractapi.TransactionContextInterface, instance *ContractInstance, fireflyTranID string, messageID string, key1 string, key2 string) error {\n\tcollectiveMessage, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"CollectiveMessage %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tmessage, ok := collectiveMessage.Messages[key1][key2]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message with key1 %s key2 %s does not exist in CollectiveMessage %s\", key1, key2, messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn errors.New(errorMessage)\n\t}\n\n\tmessage.FireflyTranID = fireflyTranID\n\tcollectiveMessage.Messages[key1][key2] = message\n\n\tinstance.InstanceMessages[messageID] = collectiveMessage\n\n\treturn nil\n}\n\nfunc (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\terrorMessage := fmt.Sprintf(\"Instance %s does not exist\", instanceID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &instance.InstanceStateMemory, nil\n\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instance *ContractInstance, globalVariable *StateMemory) error {\n\tinstance.InstanceStateMemory = *globalVariable\n\treturn nil\n}\n\nfunc (cc *SmartContract) ReadBusinessRule(ctx contractapi.TransactionContextInterface, instance *ContractInstance, BusinessRuleID string) (*BusinessRule, error) {\n\tbusinessRule, ok := instance.InstanceBusinessRules[BusinessRuleID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"BusinessRule %s does not exist\", BusinessRuleID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn businessRule, nil\n}\n\nfunc (cc *SmartContract) ReadCollectiveParticipant(ctx contractapi.TransactionContextInterface, instance *ContractInstance, participantID string) (*CollectiveParticipant, error) {\n\tcollectiveParticipant, ok := instance.InstanceParticipants[participantID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"CollectiveParticipant %s does not exist\", participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn collectiveParticipant, nil\n}\n\nfunc (cc *SmartContract) ReadAtomicParticipant(ctx contractapi.TransactionContextInterface, instance *ContractInstance, participantID string, key string) (*Participant, error) {\n\tcollectiveParticipant, ok := instance.InstanceParticipants[participantID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"CollectiveParticipant %s does not exist\", participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\tatomicParticipant, ok := collectiveParticipant.Participants[key]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Participant with key %s does not exist in CollectiveParticipant %s\", key, participantID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn &atomicParticipant, nil\n}\n\nfunc (cc *SmartContract) get_X509_identity(ctx contractapi.TransactionContextInterface) string {\n\tmspID, _ := ctx.GetClientIdentity().GetMSPID()\n\tcertificateID, _ := ctx.GetClientIdentity().GetID()\n\treturn certificateID + \"@\" + mspID\n}\n\nfunc (cc *SmartContract) check_msp(ctx contractapi.TransactionContextInterface, instance *ContractInstance, target_participant string, key string) bool {\n\ttargetParticipant, err := cc.ReadAtomicParticipant(ctx, instance, target_participant, key)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to read participant: %v\\n\", err)\n\t\treturn false\n\t}\n\n\tmspID, err := ctx.GetClientIdentity().GetMSPID()\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to get client MSP ID: %v\\n\", err)\n\t\treturn false\n\t}\n\n\treturn mspID == targetParticipant.MSP\n}\n\nfunc (cc *SmartContract) check_attribute(ctx contractapi.TransactionContextInterface, instance *ContractInstance, target_participant string, attributeName string) bool {\n\tcollectiveParticipant, err := cc.ReadCollectiveParticipant(ctx, instance, target_participant)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to read collective participant: %v\\n\", err)\n\t\treturn false\n\t}\n\n\tattributeValue, ok := collectiveParticipant.Attributes[attributeName]\n\tif !ok {\n\t\tfmt.Printf(\"Attribute %s does not exist for collective participant %s\\n\", attributeName, target_participant)\n\t\treturn false\n\t}\n\n\tif ctx.GetClientIdentity().AssertAttributeValue(attributeName, attributeValue) != nil {\n\t\tfmt.Printf(\"Client attribute value does not match for attribute %s\\n\", attributeName)\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (cc *SmartContract) check_participant(ctx contractapi.TransactionContextInterface, instance *ContractInstance, target_participant string, key string) bool {\n\tcollectiveParticipant, err := cc.ReadCollectiveParticipant(ctx, instance, target_participant)\n\tif err != nil {\n\t\tfmt.Printf(\"Failed to read collective participant: %v\\n\", err)\n\t\treturn false\n\t}\n\n\tif key == \"\" {\n\t\t// only check Participant based on Attributes in CollectiveParticipant\n\t\tfor attrName := range collectiveParticipant.Attributes {\n\t\t\tif !cc.check_attribute(ctx, instance, target_participant, attrName) {\n\t\t\t\tfmt.Printf(\"Attribute check failed for attribute %s\\n\", attrName)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tif !collectiveParticipant.IsMulti {\n\t\tdefaultKey := fmt.Sprintf(\"%s\", target_participant)\n\t\tdefaultParticipant, ok := collectiveParticipant.Participants[defaultKey]\n\t\tif !ok {\n\t\t\tfmt.Printf(\"Default participant with key %s does not exist\\n\", defaultKey)\n\t\t\treturn false\n\t\t}\n\n\t\tif defaultParticipant.X509 != \"\" {\n\t\t\texpectedX509 := cc.get_X509_identity(ctx)\n\t\t\tif defaultParticipant.X509 != expectedX509 {\n\t\t\t\tfmt.Printf(\"X509 does not match. Expected: %s, Actual: %s\\n\", expectedX509, defaultParticipant.X509)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\n\t\tfor attrName := range collectiveParticipant.Attributes {\n\t\t\tif !cc.check_attribute(ctx, instance, target_participant, attrName) {\n\t\t\t\tfmt.Printf(\"Attribute check failed for attribute %s\\n\", attrName)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tparticipant, ok := collectiveParticipant.Participants[key]\n\tif !ok {\n\t\tfmt.Printf(\"Participant with key %s does not exist\\n\", key)\n\t\treturn false\n\t}\n\n\tif participant.X509 != \"\" {\n\t\tmspID, err := ctx.GetClientIdentity().GetMSPID()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to get client MSP ID: %v\\n\", err)\n\t\t\treturn false\n\t\t}\n\t\tpid, err := ctx.GetClientIdentity().GetID()\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Failed to get client ID: %v\\n\", err)\n\t\t\treturn false\n\t\t}\n\t\texpectedX509 := pid + \"@\" + mspID\n\t\tif participant.X509 != expectedX509 {\n\t\t\tfmt.Printf(\"X509 does not match. Expected: %s, Actual: %s\\n\", expectedX509, participant.X509)\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}\n\n\tfor attrName := range collectiveParticipant.Attributes {\n\t\tif !cc.check_attribute(ctx, instance, target_participant, attrName) {\n\t\t\tfmt.Printf(\"Attribute check failed for attribute %s\\n\", attrName)\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (cc *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {\n\tstub := ctx.GetStub()\n\n\t// isInited in state\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"Failed to get isInited: %v\", err)\n\t}\n\tif isInitedBytes != nil {\n\t\terrorMessage := \"Chaincode has already been initialized\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}\n\n\tstub.PutState(\"currentInstanceID\", []byte(\"0\"))\n\n\tstub.PutState(\"isInited\", []byte(\"true\"))\n\n\tstub.SetEvent(\"initContractEvent\", []byte(\"Contract has been initialized successfully\"))\n\treturn nil\n}\n\nfunc (s *SmartContract) hashXML(ctx contractapi.TransactionContextInterface, xmlString string) (string, error) {\n\t// Calculate SHA-256 hash\n\thash := sha256.New()\n\thash.Write([]byte(xmlString))\n\thashInBytes := hash.Sum(nil)\n\thashString := hex.EncodeToString(hashInBytes)\n\tfmt.Print(hashString)\n\treturn hashString, nil\n}\n\nfunc (c *SmartContract) ReadCollectiveMsg(ctx contractapi.TransactionContextInterface, instance *ContractInstance, messageID string) (*CollectiveMessage, error) {\n\tcollectiveMsg, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"CollectiveMessage %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn collectiveMsg, nil\n}\n\nfunc (c *SmartContract) ReadAtomicMsg(ctx contractapi.TransactionContextInterface, instance *ContractInstance, messageID string, key1 string, key2 string) (*Message, error) {\n\tcollectiveMsg, ok := instance.InstanceMessages[messageID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"CollectiveMessage %s does not exist\", messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\tatomicMsg, ok := collectiveMsg.Messages[key1][key2]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"Message with key1 %s, key2 %s does not exist in CollectiveMessage %s\", key1, key2, messageID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn &atomicMsg, nil\n}\n\nfunc (c *SmartContract) ReadChoreographyTask(ctx contractapi.TransactionContextInterface, instance *ContractInstance, choreographyTaskID string) (*ChoreographyTask, error) {\n\tchoreographyTask, ok := instance.InstanceChoreographyTasks[choreographyTaskID]\n\tif !ok {\n\t\terrorMessage := fmt.Sprintf(\"ChoreographyTask %s does not exist\", choreographyTaskID)\n\t\tfmt.Println(errorMessage)\n\t\treturn nil, errors.New(errorMessage)\n\t}\n\n\treturn choreographyTask, nil\n}\n\nfunc (c *SmartContract) GetCurrentState(ctx contractapi.TransactionContextInterface, instanceID string) (string, error) {\n\tinstance, err := c.GetInstance(ctx, instanceID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn instance.CurrentState, nil\n}",
  "InitMessageFrame": "\tcc.CreateMessage(ctx, &instance, \"{message}\", \"{sender}\", \"{receiver}\", \"\", `{format}`, {is_multi}, \"{choreographyTask}\")",
  "InitGatewayFrame": "\tcc.CreateGateway(ctx, &instance, \"{gateway}\", DISABLED)\n",
  "InitChoreographyTaskFrame": "\tcc.CreateChoreographyTask(ctx, &instance, \"{choreographyTask}\", {is_multi}, \"{multi_type}\", \"{init_message}\", \"{response_message}\")",
  "ChangeEventStateFrame": "    cc.ChangeEventState(ctx, instance, \"{event}\", {state})",
  "ChangeMsgStateFrame": "    cc.ChangeMsgState(ctx, instance, \"{message}\", {state})",
  "ChangeGtwStateFrame": "    cc.ChangeGtwState(ctx, instance, \"{gateway}\", {state})",
  "ChangeBusinessRuleStateFrame": "cc.ChangeBusinessRuleState(ctx, instance, \"{business_rule}\", {state})",
  "EventFuncFrame": "func (cc *SmartContract) {event}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance, err := cc.GetInstance(ctx, instanceID)\n\n\n\tevent := map[string]interface{{}}{{\n\t\t\"type\": \"{event}\",\n\t}}\n\n\teventJsonBytes, _ := json.Marshal(event)\n\n\teventJsonString := string(eventJsonBytes)\n\n\tres, err := cc.Invoke_Other_chaincode(ctx, \"stateCharts\", \"default\",\n\tstateCharts.EncodeExecuteStateMachineArgs(instance.StateMachineDescription, instance.AdditionalContent, instance.CurrentState, eventJsonString))\n\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\tstate, changed := stateCharts.DecodeTriggerActionResult(res)\n\n\tfmt.Println(\"State\")\n\tfmt.Println(state)\n\n\tfmt.Println(\"Changed\")\n\tfmt.Println(changed)\n\n\t\n\tif !changed {{\n\t\treturn errors.New(\"Invalid transition\")\n\t}}\n\n\tinstance.CurrentState = state\n\n\tcc.SetInstance(ctx, instance)\n\n\tstub.SetEvent(\"{event}\", []byte(\"Contract has been started successfully\"))\n\t\n\treturn nil\n}}",
  "MessageSendFuncFrame": "func (cc *SmartContract) {message}_Send(ctx contractapi.TransactionContextInterface, instanceID string, targetTaskID int, fireflyTranID string {more_parameters}) error {{\n\tstub := ctx.GetStub()\n\tinstance,_ := cc.GetInstance(ctx, instanceID)\n\n\n\tcollectiveMsgName := \"{message}\"\n\tcollectiveMsg, _ := cc.ReadCollectiveMsg(ctx, instance, collectiveMsgName)\n\tparticipant_id := collectiveMsg.SendParticipantID\n\t\n\t// MultiTask Address Located\n\tchoreographyTaskID := collectiveMsg.ChoreographyTaskID\n\n\tchoreographyTask, _ := cc.ReadChoreographyTask(ctx, instance, choreographyTaskID)\n\tif choreographyTask.IsMulti == true {{\n\t\tif targetTaskID == 0 {{\n\t\t\tcollectiveMsgName = \"{message}\"\n\t\t}}else{{\n\t\t\tcollectiveMsgName = fmt.Sprintf(\"{message}_%d\", targetTaskID)\n\t\t}}\n\t}}\n\n\t// MultiParticipant Address Located\n\n\tcollectiveMsg, _ = cc.ReadCollectiveMsg(ctx, instance, collectiveMsgName)\n\tsendParticipantID := collectiveMsg.SendParticipantID\n\treceiveParticipantID := collectiveMsg.ReceiveParticipantID\n\tsendParticipant, _ := cc.ReadCollectiveParticipant(ctx, instance, sendParticipantID)\n\treceiveParticipant, _ := cc.ReadCollectiveParticipant(ctx, instance, receiveParticipantID)\n\n\tvar errorMessage string\n\tvar key1, key2 string\n\tvar msgsToHandle []Message = make([]Message, 0)\n\tvar eventsToTrigger []string = make([]string, 0)\n\tvar event map[string]interface{{}}\n\tvar eventJsonBytes []byte\n\tvar eventJsonString string\n\tif sendParticipant.IsMulti == false && receiveParticipant.IsMulti == false {{\n\t\t// 一对一\n\t\tkey1 = \"nonMulti\"\n\t\tkey2 = \"nonMulti\"\n\n\t\tmsgsToHandle = append(msgsToHandle, collectiveMsg.Messages[key1][key2])\n\n\t\tevent = map[string]interface{{}}{{\n\t\t\t\"type\": \"Send_{message}\",\n\t\t\t{put_more_event_parameters}\n\t\t}}\n\n\t\teventJsonBytes, _ = json.Marshal(event)\n\n\t\teventJsonString = string(eventJsonBytes)\n\n\t\teventsToTrigger = append(eventsToTrigger, eventJsonString)\n\n\t\tparticipant_key := key1\n\t\tif cc.check_participant(ctx, instance, participant_id, participant_key) == false{{\n\t\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", participant_id)\n\t\t\tfmt.Println(errorMessage)\n\t\t\treturn fmt.Errorf(errorMessage)\n\t\t}}\n\n\t}}else if sendParticipant.IsMulti == true && receiveParticipant.IsMulti == false {{\n\t\t// 多对一\n\t\tkey1 = cc.get_X509_identity(ctx)\n\t\tkey2 = \"nonMulti\"\n\n\t\t// // Auth\n\n\t\t// Check if Locked\n\t\tif sendParticipant.IsLocked == true {{\n\t\t\t// check if registered\n\t\t\tif _, ok := sendParticipant.Participants[key1]; ok {{\n\t\t\t\t// check X509\n\t\t\t\tparticipant_key := key1\n\t\t\t\tif cc.check_participant(ctx, instance, participant_id, participant_key) == false{{\n\t\t\t\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", participant_id)\n\t\t\t\t\tfmt.Println(errorMessage)\n\t\t\t\t\treturn fmt.Errorf(errorMessage)\n\t\t\t\t}}\n\t\t\t}}else {{\n\t\t\t\treturn fmt.Errorf(\"The participant is locked and the participant is not registered\")\n\t\t\t}}\n\t\t}}else {{\n\t\t\t// else check if Participant has reach Maximum\n\t\t\tif sendParticipant.MultiMaximum <= len(sendParticipant.Participants) {{\n\t\t\t\treturn fmt.Errorf(\"The number of messages sent by the participant exceeds the maximum\")\n\t\t\t}}\n\n\t\t\t// Attributes Based Access Control\n\t\t\tif cc.check_participant(ctx, instance, participant_id, \"\") == false {{\n\t\t\t\terrorMessage = fmt.Sprintf(\"Participant can't not register itself due to no conformance attributes\")\n\t\t\t\treturn fmt.Errorf(errorMessage)\n\t\t\t}}\n\n\t\t\t// Register self, using a increasing key\n\t\t\tparticipant_increasing_key := fmt.Sprintf(\"%d\",len(sendParticipant.Participants))\n\t\t\t// create new Participant if not exist\n\t\t\tmsp, _ := ctx.GetClientIdentity().GetMSPID()\n\t\t\tnewParticipant := Participant{{\n\t\t\t\tParticipantID: participant_increasing_key,\n\t\t\t\tMSP: msp,\n\t\t\t\tIsMulti: true,\n\t\t\t\tX509: key1,\n\t\t\t}}\n\t\t\tsendParticipant.Participants[key1] = newParticipant\n\t\t}}\n\n\t\t// Created Message\n\n\t\tif _, ok := collectiveMsg.Messages[key1]; ok {{\n\t\t\tfmt.Println(\"The number of messages sent by the participant exceeds the maximum\")\n\t\t}}else{{\n\t\t\tcollectiveMsg.Messages[key1] = make(map[string]Message)\n\t\t\tnewAtomicMsg := Message{{\n\t\t\t\tMessageID: collectiveMsgName,\n\t\t\t\tSendParticipantKey: key1,\n\t\t\t\tReceiveParticipantKey: key2,\n\t\t\t\tFireflyTranID: \"\",\n\t\t\t}}\n\t\t\tcollectiveMsg.Messages[key1][key2] = newAtomicMsg\n\t\t\tmessageJsonBytes, _ := json.Marshal(collectiveMsg.Messages[key1][key2])\n\t\t\tfmt.Println(string(messageJsonBytes))\n\t\t}}\n\n\t\tmessage_increasing_key:= len(sendParticipant.Participants) - 1 // reduce the one increased by self\n\t\tmsgsToHandle = append(msgsToHandle, collectiveMsg.Messages[key1][key2])\n\n\t\tevent = map[string]interface{{}}{{\n\t\t\t\"type\": fmt.Sprintf(\"Send_{message}_%d\",message_increasing_key),\n\t\t\t{put_more_event_parameters}\n\t\t}}\n\n\t\teventJsonBytes, _ = json.Marshal(event)\n\n\t\teventJsonString = string(eventJsonBytes)\n\n\t\teventsToTrigger = append(eventsToTrigger, eventJsonString)\n\n\t}}else if sendParticipant.IsMulti == false && receiveParticipant.IsMulti == true {{\n\t\t// 一对多\n\t\tkey1 = \"nonMulti\"\n\n\t\tparticipant_key := key1\n\t\tif cc.check_participant(ctx, instance, participant_id, participant_key) == false{{\n\t\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", participant_id)\n\t\t\tfmt.Println(errorMessage)\n\t\t\treturn fmt.Errorf(errorMessage)\n\t\t}}\n\n\t\t// create Maximum Number of Message\n\t\tif _, ok := collectiveMsg.Messages[key1]; ok {{\n\t\t\t// Have Been Created, Repeated Operation\t\t\n\t\t}}else{{\n\t\t\tcollectiveMsg.Messages[key1] = make(map[string]Message)\n\t\t}}\n\n\t\tif len(collectiveMsg.Messages[key1]) >= receiveParticipant.MultiMaximum {{\n\t\t\tfmt.Println(\"The number of messages sent by the participant exceeds the maximum\")\n\t\t\treturn fmt.Errorf(\"The number of messages sent by the participant exceeds the maximum\")\n\t\t}}\n\n\t\tfor i := 0; i < receiveParticipant.MultiMaximum; i++ {{\n\t\t\tkey2 := fmt.Sprintf(\"%d\", i)\n\t\t\tnewAtomicMsg := Message{{\n\t\t\t\tMessageID:            collectiveMsgName,\n\t\t\t\tSendParticipantKey:  key1,\n\t\t\t\tReceiveParticipantKey: key2,\n\t\t\t\tFireflyTranID:        \"\",\n\t\t\t}}\n\t\t\tcollectiveMsg.Messages[key1][key2] = newAtomicMsg\n\t\t}}\n\n\t\tfor key, value := range collectiveMsg.Messages[key1] {{\n\t\t\tmsgsToHandle = append(msgsToHandle, value)\n\t\t\tevent = map[string]interface{{}}{{\n\t\t\t\t\"type\": fmt.Sprintf(\"Send_{message}_%s\",key),\n\t\t\t\t{put_more_event_parameters}\n\t\t\t}}\n\t\t\teventJsonBytes, _ = json.Marshal(event)\n\t\t\teventJsonString = string(eventJsonBytes)\n\t\t\teventsToTrigger = append(eventsToTrigger, eventJsonString)\n\t\t}}\n\n\t}}else if sendParticipant.IsMulti == true && receiveParticipant.IsMulti == true {{\n\t\t// 多对多 UnSupport Type\n\t\terrorMessage = \"Multi To Multi Task, Unsupported Operation\"\n\t\tfmt.Println(errorMessage)\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\n\tfor _, event := range eventsToTrigger {{\n\n\t\tfmt.Printf(event)\n\n\t\tres, err := cc.Invoke_Other_chaincode(ctx, \"StateChartEngine:v1\", \"default\",\n\t\tstateCharts.EncodeExecuteStateMachineArgs(instance.StateMachineDescription, instance.AdditionalContent, instance.CurrentState, event))\n\n\t\tif err != nil {{\n\t\t\tfmt.Printf(err.Error())\n\t\t\treturn err\n\t\t}}\n\n\t\tfmt.Printf(string(res))\n\n\t\tstate, changed := stateCharts.DecodeTriggerActionResult(res)\n\n\t\tfmt.Printf(\"State: %s\\n\", state)\n\t\tfmt.Printf(\"Changed: %t\\n\", changed)\n\n\t\tif !changed {{\n\t\t\treturn fmt.Errorf(\"The state machine does not change\")\n\t\t}}\n\t\tinstance.CurrentState = state\n\t}}\n\n\tinstanceJson, _ := json.Marshal(instance)\n\tfmt.Println(string(instanceJson))\n\n\tfor _, msg := range msgsToHandle {{\n\t\tcc.ChangeMsgFireflyTranID(ctx, instance, fireflyTranID, msg.MessageID, key1, key2)\n\t}}\n\n\t{put_more_parameters}\n\t\n\tstub.SetEvent(collectiveMsgName, []byte(\"Message is waiting for confirmation\"))\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "MessageCompleteFuncFrame": "func (cc *SmartContract) {message}_Complete(ctx contractapi.TransactionContextInterface, instanceID string, targetTaskID int, ConfirmTargetX509 string) error {{\n\tstub := ctx.GetStub()\n\tinstance,_ := cc.GetInstance(ctx, instanceID)\n\n\tcollectiveMsgName := \"{message}\"\n\tcollectiveMsg, _ := cc.ReadCollectiveMsg(ctx, instance, collectiveMsgName)\n\tparticipant_id := collectiveMsg.ReceiveParticipantID\n\t\n\t// MultiTask Address Located\n\tchoreographyTaskID := collectiveMsg.ChoreographyTaskID\n\n\tchoreographyTask, _ := cc.ReadChoreographyTask(ctx, instance, choreographyTaskID)\n\tif choreographyTask.IsMulti == true {{\n\t\tif targetTaskID == 0 {{\n\t\t\tcollectiveMsgName = \"{message}\"\n\t\t}}else{{\n\t\t\tcollectiveMsgName = fmt.Sprintf(\"{message}_%d\", targetTaskID)\n\t\t}}\n\t}}\n\n\tcollectiveMsg, _ = cc.ReadCollectiveMsg(ctx, instance, collectiveMsgName)\n\tsendParticipantID := collectiveMsg.SendParticipantID\n\treceiveParticipantID := collectiveMsg.ReceiveParticipantID\n\tsendParticipant, _ := cc.ReadCollectiveParticipant(ctx, instance, sendParticipantID)\n\treceiveParticipant, _ := cc.ReadCollectiveParticipant(ctx, instance, receiveParticipantID)\n\n\tvar errorMessage string\n\tvar key1, key2 string\n\tvar msgsToHandle []Message = make([]Message, 0)\n\tvar eventsToTrigger []string = make([]string,0)\n\tvar event map[string]interface{{}}\n\tvar eventJsonString string\n\tvar eventJsonBytes []byte\n\tif sendParticipant.IsMulti == false && receiveParticipant.IsMulti == false {{\n\t\t// 一对一\n\t\tkey1 = \"nonMulti\"\n\t\tkey2 = \"nonMulti\"\n\t\tmsgsToHandle = append(msgsToHandle, collectiveMsg.Messages[key1][key2])\n\n\t\tevent = map[string]interface{{}}{{\n\t\t\t\"type\": \"Confirm_{message}\",\n\t\t}}\n\n\t\teventJsonBytes, _ = json.Marshal(event)\n\n\t\teventJsonString = string(eventJsonBytes)\n\t\teventsToTrigger = append(eventsToTrigger, eventJsonString)\n\n\t\tparticipant_key := key2\n\t\tif cc.check_participant(ctx, instance, participant_id, participant_key) == false{{\n\t\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", participant_id)\n\t\t\tfmt.Println(errorMessage)\n\t\t\treturn fmt.Errorf(errorMessage)\n\t\t}}\n\n\t}}else if sendParticipant.IsMulti == true && receiveParticipant.IsMulti == false {{\n\t\t// 多对一 回应 \n\t\t// 1. 响应所有消息\n\t\t// 2. 添加Target\n\n\t\tkey1 = ConfirmTargetX509\n\t\tkey2 = \"nonMulti\"\n\n\t\tparticipant_key := key2\n\t\tif cc.check_participant(ctx, instance, participant_id, participant_key) == false{{\n\t\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", participant_id)\n\t\t\tfmt.Println(errorMessage)\n\t\t\treturn fmt.Errorf(errorMessage)\n\t\t}}\n\n\t\t// Which To Confirm? Decided By ConfirmTargetX509\n\t\tconfirmTargetSender, ok := sendParticipant.Participants[key1];\n\t\tif  !ok {{\n\t\t\terrorMessage := \"UnExisted ConfirmTarget\"\n\t\t\treturn fmt.Errorf(errorMessage)\n\t\t}}\n\n\t\tmsgsToHandle = append(msgsToHandle, collectiveMsg.Messages[key1][\"nonMulti\"])\n\n\t\tevent = map[string]interface{{}}{{\n\t\t\t\"type\": fmt.Sprintf(\"Confirm_{message}_%s\", confirmTargetSender.ParticipantID),\n\t\t}}\n\n\t\teventJsonBytes, _ = json.Marshal(event)\n\n\t\teventJsonString = string(eventJsonBytes)\n\n\t\teventsToTrigger = append(eventsToTrigger, eventJsonString)\n\t}}else if sendParticipant.IsMulti == false && receiveParticipant.IsMulti == true {{\n\t\t// 一对多 回应，响应自己的部分，修改计数器\n\t\tkey1 = \"nonMulti\"\n\t\tkey2 = cc.get_X509_identity(ctx)\n\n\t\tif receiveParticipant.IsLocked == true {{\n\t\t\t// check if key2 in it\n\t\t\tif _, ok := receiveParticipant.Participants[key2]; ok {{\n\t\t\t\t// check Participant\n\t\t\t\tparticipant_key := key2\n\t\t\t\tif cc.check_participant(ctx, instance, participant_id, participant_key) == false{{\n\t\t\t\t\terrorMessage := fmt.Sprintf(\"Participant %s is not allowed to send the message\", participant_id)\n\t\t\t\t\tfmt.Println(errorMessage)\n\t\t\t\t\treturn fmt.Errorf(errorMessage)\n\t\t\t\t}}\n\t\t\t}}else {{\n\t\t\t\treturn fmt.Errorf(\"The participant is locked and the participant is not registered\")\n\t\t\t}}\n\t\t}}else{{\n\n\t\t\tif receiveParticipant.MultiMaximum <= len(receiveParticipant.Participants) {{\n\t\t\t\terrorMessage := \"ReceiveParticipants Has Reach the Maximum\"\n\t\t\t\treturn fmt.Errorf(errorMessage)\n\t\t\t}}\n\n\t\t\tif cc.check_participant(ctx, instance, participant_id, \"\") != true {{\n\t\t\t\terrorMessage := \"Not Allowed To participate as a Receiver\"\n\t\t\t\treturn fmt.Errorf(errorMessage)\n\t\t\t}}\n\n\t\t\t// create new Participant if not exist\n\t\t\tx509 := cc.get_X509_identity(ctx)\n\t\t\tparticipant_increasing_key := len(receiveParticipant.Participants)\n\t\t\tmsp, _ := ctx.GetClientIdentity().GetMSPID()\n\t\t\tnewParticipant := Participant{{\n\t\t\t\tParticipantID: fmt.Sprintf(\"%d\",participant_increasing_key),\n\t\t\t\tMSP: msp,\n\t\t\t\tIsMulti: true,\n\t\t\t\tX509: x509,\n\t\t\t}}\n\t\t\treceiveParticipant.Participants[key2] = newParticipant\n\t\t}}\n\n\t\t// get the message and increase it's confirmedCount\n\n\n\t\tif collectiveMsg.MessageConfirmedCount >= receiveParticipant.MultiMaximum {{\n\t\t\treturn fmt.Errorf(\"The number of messages sent by the participant exceeds the maximum\")\n\t\t}}\n\n\t\tmessage_increasing_key := fmt.Sprintf(\"%d\",collectiveMsg.MessageConfirmedCount)\n\t\tmsg := collectiveMsg.Messages[key1][message_increasing_key]\n\t\tdelete(collectiveMsg.Messages[key1], message_increasing_key)\n\t\tcollectiveMsg.Messages[key1][key2] = msg\n\t\tcollectiveMsg.MessageConfirmedCount += 1\n\n\n\t\tmsgsToHandle = append(msgsToHandle, msg)\n\n\t\tevent = map[string]interface{{}}{{\n\t\t\t\"type\": fmt.Sprintf(\"Confirm_{message}_%d\", message_increasing_key),\n\t\t}}\n\n\t\teventJsonBytes, _ = json.Marshal(event)\n\n\t\teventJsonString = string(eventJsonBytes)\n\n\t\teventsToTrigger = append(eventsToTrigger, eventJsonString)\n\n\t}}else if sendParticipant.IsMulti == true && receiveParticipant.IsMulti == true {{\n\t\t// 多对多 UnSupported Operations?\n\t\terrorMessage = fmt.Sprintf(\"UnSupported Operation\")\n\t\treturn fmt.Errorf(errorMessage)\n\t}}\n\n\n\tfor _, event := range eventsToTrigger {{\n\n\t\tfmt.Println(\"Event\")\n\t\tfmt.Println(event)\n\n\t\tres,err := cc.Invoke_Other_chaincode(ctx, \"StateChartEngine:v1\", \"default\",\n\t\tstateCharts.EncodeExecuteStateMachineArgs(instance.StateMachineDescription, instance.AdditionalContent, instance.CurrentState, event))\n\t\tif err != nil {{\n\t\t\treturn err\n\t\t}}\n\t\tstate, changed := stateCharts.DecodeTriggerActionResult(res)\n\n\t\tfmt.Println(\"State\")\n\t\tfmt.Println(state)\n\n\t\tfmt.Println(\"Changed\")\n\t\tfmt.Println(changed)\n\n\t\tif !changed {{\n\t\t\treturn fmt.Errorf(\"The state machine does not change\")\n\t\t}}\n\n\t\tinstance.CurrentState = state\n\t}} \n\n\tstub.SetEvent(collectiveMsgName, []byte(\"Message is Confirmed !\"))\n\tcc.SetInstance(ctx, instance)\n\treturn nil\n}}",
  "GatewayFuncFrame": "func (cc *SmartContract) {gateway}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\tstub := ctx.GetStub()\n\tinstance, err := cc.GetInstance(ctx, instanceID)\n\t\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\n\tevent := map[string]interface{{}}{{\n\t\t\"type\": \"{gateway}\",\n\t}}\n\n\teventJsonBytes, _ := json.Marshal(event)\n\n\teventJsonString := string(eventJsonBytes)\n\n\tres, err := cc.Invoke_Other_chaincode(ctx, \"StateChartEngine:v1\", \"default\",\n\tstateCharts.EncodeExecuteStateMachineArgs(instance.StateMachineDescription, instance.AdditionalContent, instance.CurrentState, eventJsonString))\n\t\n\tif err != nil {{\n\t\treturn err\n\t}}\n\tnew_status, changed := stateCharts.DecodeTriggerActionResult(res)\n\n\tfmt.Println(\"State\")\n\tfmt.Println(new_status)\n\n\tfmt.Println(\"Changed\")\n\tfmt.Println(changed)\n\n\n\tif !changed {{\n\t\treturn errors.New(\"Invalid transition\")\n\t}}\n\n\tinstance.CurrentState = new_status\n\tcc.SetInstance(ctx, instance)\n\n\n\tstub.SetEvent(\"{gateway}\", []byte(\"Gateway has been done\"))\n\t\n\treturn nil\n}}",
  "ConditionToDoFrame": "if {condition} {{\n\t{todo}\n}}",
  "StateMemoryDefinitionFrame": "type StateMemory struct {{\n    {fields}\n}}",
  "StateReadAndSetFunc": "func (cc *SmartContract) ReadState(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tstateJSON, err := ctx.GetStub().GetState(\"currentMemory\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif stateJSON == nil {\n\t\t// return a empty stateMemory\n\t\treturn &StateMemory{}, nil\n\t}\n\n\tvar stateMemory StateMemory\n\terr = json.Unmarshal(stateJSON, &stateMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn nil, err\n\t}\n\n\treturn &stateMemory, nil\n}\n\nfunc (cc *SmartContract) PutState(ctx contractapi.TransactionContextInterface, stateName string, stateValue interface{}) error {\n\tstub := ctx.GetStub()\n\tcurrentMemory, err := cc.ReadState(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tval := reflect.ValueOf(currentMemory)\n\tif val.Kind() != reflect.Ptr || val.Elem().Kind() != reflect.Struct {\n\t\treturn errors.New(\"currentMemory is not a struct pointer\")\n\t}\n\tfield := val.Elem().FieldByName(stateName)\n\tif !field.IsValid() {\n\t\treturn errors.New(\"field does not exist\")\n\t}\n\tif !field.CanSet() {\n\t\treturn errors.New(\"field cannot be set\")\n\t}\n\t// 根据字段类型将stateValue转换为合适的类型\n\tswitch field.Interface().(type) {\n\tcase string:\n\t\tstringValue, ok := stateValue.(string)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a string\")\n\t\t}\n\t\tfield.SetString(stringValue)\n\tcase int:\n\t\tintValue, ok := stateValue.(int)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not an int\")\n\t\t}\n\t\tfield.SetInt(int64(intValue))\n\tcase float64:\n\t\tfloatValue, ok := stateValue.(float64)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a float64\")\n\t\t}\n\t\tfield.SetFloat(floatValue)\n\tcase bool:\n\t\tboolValue, ok := stateValue.(bool)\n\t\tif !ok {\n\t\t\treturn errors.New(\"stateValue is not a bool\")\n\t\t}\n\t\tfield.SetBool(boolValue)\n\t// 添加其他类型的处理...\n\tdefault:\n\t\treturn errors.New(\"unsupported field type\")\n\t}\n\n\tcurrentMemoryJSON, err := json.Marshal(currentMemory)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\terr = stub.PutState(\"currentMemory\", currentMemoryJSON)\n\tif err != nil {\n\t\tfmt.Println(err.Error())\n\t\treturn err\n\t}\n\n\treturn nil\n}",
  "PutStateFuncFrame": "    cc.PutState(ctx, instanceID, \"{name}\", {value})",
  "ReadStateFuncFrame": "    {stateName}:=currentMemory.{stateName}\n",
  "ReadCurrentMemoryCode": "    currentMemory,err := cc.ReadState(ctx)\n    if err != nil {\n        return err\n    }\n",
  "ReadAndSetGloablVariable": "func (cc *SmartContract) ReadGlobalVariable(ctx contractapi.TransactionContextInterface, instanceID string) (*StateMemory, error) {\n\tinstanceJson, err := ctx.GetStub().GetState(instanceID)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif instanceJson == nil {\n\t\treturn nil, fmt.Errorf(\"The instance %s does not exist\", instanceID)\n\t}\n\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceJson, &instance)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tstateMemory, ok := instance.StateMemory.(*StateMemory)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"The instance %s has no valid StateMemory\", instanceID)\n\t}\n\n\treturn stateMemory, nil\n}\n\nfunc (cc *SmartContract) SetGlobalVariable(ctx contractapi.TransactionContextInterface, instance *ContractInstance, globalVariable *StateMemory) error {\n\tinstance.StateMemory = globalVariable\n\treturn instance\n\n}",
  "SetGlobalVariableFuncFrame": "\tglobalMemory,readGloabolError := cc.ReadGlobalVariable(ctx, instanceID)\n\tif readGloabolError != nil {{\n\t\tfmt.Println(readGloabolError.Error())\n\t\treturn readGloabolError\n\t}}\n\t{items}\n\tsetGloabolErrror :=cc.SetGlobalVariable(ctx, instance, globalMemory)\n\tif setGloabolErrror != nil {{\n\t\tfmt.Println(setGloabolErrror.Error())\n\t\treturn setGloabolErrror\n\t}}",
  "SetGlobalVaribaleFuncItemFrame": "\tglobalMemory.{name} = {value}",
  "ReadGlobalVariable": "\tcurrentMemory, err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif err != nil {\n\t\treturn err\n\t}\n",
  "InitParticipantFrame": "\tcc.CreateParticipant(ctx, &instance, \"{participant_id}\", initParameters.{participant_id}.MSP, initParameters.{participant_id}.Attributes, initParameters.{participant_id}.X509,initParameters.{participant_id}.IsMulti, {multi_maximum}, {multi_minimum})",
  "CreateInstanceFuncFrame": "func (cc *SmartContract) CreateInstance(ctx contractapi.TransactionContextInterface, initParametersBytes string) (string, error) {{\n\tstub := ctx.GetStub()\n\n\tisInitedBytes, err := stub.GetState(\"isInited\")\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to read from world state. %s\", err.Error())\n\t}}\n\n\tif isInitedBytes == nil {{\n\t\treturn \"\", fmt.Errorf(\"The instance has not been initialized.\")\n\t}}\n\n\tisInited, err := strconv.ParseBool(string(isInitedBytes))\n\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"fail To Resolve isInited\")\n\t}}\n\tif !isInited {{\n\t\treturn \"\", fmt.Errorf(\"The instance has not been initialized.\")\n\t}}\n\n\t// get the instanceID\n\tinstanceIDBytes, err := stub.GetState(\"currentInstanceID\")\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to read from world state. %s\", err.Error())\n\t}}\n\n\tinstanceID := string(instanceIDBytes)\n\t\n\n\t// Create the instance with the data from the InitParameters\n\tvar initParameters InitParameters\n\terr = json.Unmarshal([]byte(initParametersBytes), &initParameters)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to unmarshal. %s\", err.Error())\n\t}}\n\n\n\tfmt.Println(\"InitParameters: \", initParameters.StateMachineDescription)\n\tfmt.Println(\"InitParameters: \", initParameters.AdditionalContent)\n\t\n\tres, err := cc.Invoke_Other_chaincode(ctx, \"StateChartEngine:v1\", \"default\", stateCharts.EncodeGetDefaultSnapshotArgs(initParameters.StateMachineDescription, initParameters.AdditionalContent))\n\n\tif err != nil {{\n\t\tfmt.Println(\"Error Happend\")\n\t\tfmt.Print(err.Error())\n\t}}\n\n\tfmt.Println(\"Res:\")\n\tfmt.Println(string(res))\n\n\tinitialSnapshot := stateCharts.DecodeGetDefaultSnapshotResult(res)\n\n\tfmt.Println(\"InitialSnapshot\")\n\tfmt.Println(initialSnapshot)\n\n\tinstance := ContractInstance{{\n\t\tInstanceID:          instanceID,\n\t\tInstanceStateMemory: StateMemory{{}},\n\t\tInstanceMessages:    make(map[string]*CollectiveMessage),\n\t\tInstanceParticipants : make(map[string]*CollectiveParticipant),\n\t\tInstanceBusinessRules: make(map[string]*BusinessRule),\n\t\tInstanceChoreographyTasks: make(map[string]*ChoreographyTask),\n\t\tCurrentState:\tinitialSnapshot,\n\t\tStateMachineDescription: initParameters.StateMachineDescription,\n\t\tAdditionalContent: initParameters.AdditionalContent,\n\t}}\n\n\t// Update the currentInstanceID\n\n\t{create_elements_code}\n\n\t// Save the instance\n\tinstanceBytes, err := json.Marshal(instance)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to marshal. %s\", err.Error())\n\t}}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to put state. %s\", err.Error())\n\t}}\n\n\n\teventPayload := map[string]string{{\n\t\t\"InstanceID\": instanceID, \n\t\t{event_content}\n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"InstanceCreated\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\n\tinstanceIDInt, err := strconv.Atoi(instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to convert instanceID to int. %s\", err.Error())\n\t}}\n\n\tinstanceIDInt++\n\tinstanceID = strconv.Itoa(instanceIDInt)\n\n\tinstanceIDBytes = []byte(instanceID)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to marshal instanceID. %s\", err.Error())\n\t}}\n\n\terr = stub.PutState(\"currentInstanceID\", instanceIDBytes)\n\tif err != nil {{\n\t\treturn \"\", fmt.Errorf(\"failed to put state. %s\", err.Error())\n\t}}\n\n\treturn instanceID, nil\n\n}}",
  "InitParametersTypeDefFrame": "type InitParameters struct {{\n    {fields}\n    StateMachineDescription string `json:\"stateMachineDescription\"`\n    AdditionalContent string `json:\"additionalContent\"`\n}}",
  "InvokeChaincodeFunc": "func (cc *SmartContract) Invoke_Other_chaincode(ctx contractapi.TransactionContextInterface, chaincodeName string, channel string, _args [][]byte) ([]byte, error) {\n\tstub := ctx.GetStub()\n\tresponse := stub.InvokeChaincode(chaincodeName, _args, channel)\n\n\tif response.Status != shim.OK {\n\t\treturn []byte(\"\"), fmt.Errorf(\"failed to invoke chaincode. Response status: %d. Response message: %s\", response.Status, response.Message)\n\t}\n\n\tfmt.Print(\"response.Payload: \")\n\tfmt.Println(string(response.Payload))\n\n\treturn response.Payload, nil\n}",
  "RegisterFunc": "func (cc *SmartContract) RegisterParticipant(ctx contractapi.TransactionContextInterface, instanceID string, targetParticipantID string) error {\n\t{\n\t\t// check if the participant is single\n\t\tvar targetParticipant Participant\n\t\tparticipant, _ := cc.ReadParticipant(ctx, instanceID, targetParticipantID)\n\t\tif participant.IsMulti {\n\t\t\t{\n\t\t\t\treturn fmt.Errorf(\"The participant is not multi\")\n\t\t\t}\n\t\t}\n\n\t\t// check ACL\n\n\t\tif !cc.check_participant(ctx, instanceID, targetParticipantID) {\n\t\t\treturn fmt.Errorf(\"The participant is not allowed to be registered\")\n\t\t}\n\n\t\t// Read the identity of invoker ,and binding it's identity to the participant\n\n\t\t// Get the identity of the invoker\n\t\tinvokerIdentity, err := ctx.GetClientIdentity().GetID()\n\t\tmspIndentity, err := ctx.GetClientIdentity().GetMSPID()\n\n\t\tX509 := invokerIdentity + \"@\" + mspIndentity\n\n\t\t// save the identity to the participant\n\t\ttargetParticipant.X509 = X509\n\n\t\t// save the participant\n\t\terr = cc.WriteParticipant(ctx, instanceID, targetParticipantID, &targetParticipant)\n\t\tif err != nil {\n\t\t\t{\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}",
  "CheckRegisterFunc": "func (cc *SmartContract) CheckRegister(ctx contractapi.TransactionContextInterface, instanceID string) (bool, error) {\n\tstub := ctx.GetStub()\n\n\t// Check if the instance has been registered\n\tinstanceBytes, err := stub.GetState(instanceID)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to read from world state. %s\", err.Error())\n\t}\n\tvar instance ContractInstance\n\terr = json.Unmarshal(instanceBytes, &instance)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to unmarshal. %s\", err.Error())\n\t}\n\n\tif instance.InstanceState == READY {\n\t\treturn true, nil\n\t}\n\n\t// set State depend on Participant with IsMulti=true\n\n\tfor element, value := range instance.InstanceElements {\n\t\tparticipant, ok := value.(*Participant)\n\t\tif ok {\n\t\t\tif !participant.IsMulti && participant.X509 == \"\" {\n\t\t\t\treturn false, fmt.Errorf(\"The participant %s is not registered.\", element)\n\t\t\t}\n\t\t}\n\t}\n\n\t// set State depend on Participant with IsMulti=false\n\tinstance.InstanceState = READY\n\tinstanceBytes, err = json.Marshal(instance)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to marshal. %s\", err.Error())\n\t}\n\n\terr = stub.PutState(instanceID, instanceBytes)\n\tif err != nil {\n\t\treturn false, fmt.Errorf(\"Failed to put state. %s\", err.Error())\n\t}\n\n\treturn true, nil\n}",
  "InitBusinessRuleFrame": "\tcc.CreateBusinessRule(ctx, &instance, \"{business_rule}\", initParameters.{business_rule}_Content, initParameters.{business_rule}_DecisionID, initParameters.{business_rule}_ParamMapping)",
  "BusinessRuleFuncFrame": "func (cc *SmartContract) {business_rule}(ctx contractapi.TransactionContextInterface, instanceID string) error {{\n\n\n\tinstance, err := cc.GetInstance(ctx, instanceID)\n\t// Read Business Info\n\tbusinessRule, err := cc.ReadBusinessRule(ctx, instanceID, \"{business_rule}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t// Check the BusinessRule State\n\tif businessRule.State != ENABLED {{\n\t\treturn fmt.Errorf(\"The BusinessRule is not ENABLED\")\n\t}}\n\n\t// Get the CID\n\n\tres,err := cc.Invoke_Other_chaincode(ctx, \"Oracle:v1\", \"default\", oracle.EncodeGetDataItemArgs(\n\t\tinstanceID, \"{business_rule}\",\n\t))\n\tif err != nil {{\n\t\treturn  err\n\t}}\n\n\tvar dataItem *oracle.DataItem\n\tdataItem, err = oracle.DecodeGetDataItemResult(res)\n\tif err != nil {{\n\t\treturn  err\n\t}}\n\n\teventPayload := map[string]string{{\n\t\t\"ID\":        \"{business_rule}\",\n\t\t\"InstanceID\": instanceID,\n\t\t\"Func\":\t   \"{business_rule}_Continue\",\n\t\t\"CID\": dataItem.Value, \n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"DMNContentRequired\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\n\tcc.ChangeBusinessRuleState(ctx, instance, \"{business_rule}\", WAITINGFORCONFIRMATION)\n\tcc.SetInstance(ctx, instance)\n\n\treturn nil\n}}",
  "BusinessRuleContinueFuncFrame": "func (cc *SmartContract) {business_rule}_Continue(ctx contractapi.TransactionContextInterface, instanceID string, ContentOfDmn string) error {{\n\t// Read Business Info\n\tinstance,err:=cc.GetInstance(ctx, instanceID)\n\tbusinessRule, err := cc.ReadBusinessRule(ctx, instanceID, \"{business_rule}\")\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\t// Check the BusinessRule State\n\tif businessRule.State != WAITINGFORCONFIRMATION {{\n\t\treturn fmt.Errorf(\"The BusinessRule is not Actived\")\n\t}}\n\n\t// check the hash\n\thashString, _ := cc.hashXML(ctx, ContentOfDmn)\n\tif hashString != businessRule.Hash {{\n\t\treturn fmt.Errorf(\"The hash is not matched\")\n\t}}\n\n\t// Combine the Parameters\n\t_args := make([][]byte, 4)\n\t_args[0] = []byte(\"createRecord\")\n\t// input in json format\n\tParamMapping := businessRule.ParamMapping\n\trealParamMapping := make(map[string]interface{{}})\n\tglobalVariable, _err := cc.ReadGlobalVariable(ctx, instanceID)\n\tif _err != nil {{\n\t\treturn _err\n\t}}\n\n\tfor key, value := range ParamMapping {{\n\t\tfield := reflect.ValueOf(globalVariable).Elem().FieldByName(strings.Title(value))\n\t\tif !field.IsValid() {{\n\t\t\treturn fmt.Errorf(\"The field %s is not valid\", value)\n\t\t}}\n\t\trealParamMapping[key] = field.Interface()\t\t\n\t}}\n\tvar inputJsonBytes []byte\n\tinputJsonBytes, err= json.Marshal(realParamMapping)\n\tif err != nil {{\n\t\treturn err\n\t}}\n\t_args[1] = inputJsonBytes\n\n\t// DMN Content\n\t_args[2] = []byte(ContentOfDmn)\n\n\t// decisionId\n\t_args[3] = []byte(businessRule.DecisionID)\n\n\t// Invoke DMN Engine Chaincode\n\tvar resJson []byte\n\tresJson, err=cc.Invoke_Other_chaincode(ctx, \"DMNEngine:v1\",\"default\", _args)\n\n\t// Set the Result\n\tvar res map[string]interface{{}}\n\terr = json.Unmarshal(resJson, &res)\n\tif err != nil {{\n\t\treturn err\n\t}}\n\n\toutput := res[\"output\"]\n\tfmt.Println(\"output: \", output)  \n\tif outputArr, ok := output.([]interface{{}}); ok {{  \n\t\tfor _, item := range outputArr {{  \n\t\t\titemMap := item.(map[string]interface{{}})  \n\t\t\tfor key, value := range itemMap {{  \n\t\t\t\tfmt.Printf(\"Key: %s, Type: %T, Value: %v\\n\", key,value,value)  \n\t\t\t\tglobalName , _ := ParamMapping[key]\n\t\t\t\tfield := reflect.ValueOf(globalVariable).Elem().FieldByName(strings.Title(globalName))\n\t\t\t\tif !field.IsValid() {{\n\t\t\t\t\treturn fmt.Errorf(\"The field %s is not valid\", key)\n\t\t\t\t}}\n\t\t\t\tswitch field.Kind() {{\n\t\t\t\t\tcase reflect.Int:\n\t\t\t\t\t\tif valueFloat, ok := value.(float64); ok {{\n\t\t\t\t\t\t\tfield.SetInt(int64(valueFloat))\n\t\t\t\t\t\t}} else {{\n\t\t\t\t\t\t\treturn fmt.Errorf(\"Unable to convert %v to int\", value)\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase reflect.String:\n\t\t\t\t\t\tif valueStr, ok := value.(string); ok {{\n\t\t\t\t\t\t\tfield.SetString(valueStr)\n\t\t\t\t\t\t}} else {{\n\t\t\t\t\t\t\treturn fmt.Errorf(\"Unable to convert %v to string\", value)\n\t\t\t\t\t\t}}\n\t\t\t\t\tcase reflect.Bool: // 处理布尔类型\n\t\t\t\t\t\tif valueBool, ok := value.(bool); ok {{\n\t\t\t\t\t\t\tfield.SetBool(valueBool)\n\t\t\t\t\t\t}} else {{\n\t\t\t\t\t\t\treturn fmt.Errorf(\"Unable to convert %v to bool\", value)\n\t\t\t\t\t\t}}\n\t\t\t\t\t// 其他类型转换可以根据需求添加\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn fmt.Errorf(\"Unsupported field type: %s\", field.Type())\n                }}\n\t\t\t\t// field.Set(reflect.ValueOf(value))\n\t\t\t}}  \n\t\t}}  \n\t}}  \n\n\t// Update the GlobalVariable\n\terr = cc.SetGlobalVariable(ctx, instance, globalVariable)\n\n\t// Change the BusinessRule State\n\tcc.ChangeBusinessRuleState(ctx, instance, \"{business_rule}\", COMPLETED)\n\n    {pre_activate_next_hook}\n    {change_next_state_code}\n    {after_all_hook}\n\n\tcc.SetInstance(ctx, instance)\n\teventPayload := map[string]string{{\n\t\t\"ID\":         \"Activity_0ibsbry_Continue\",\n\t\t\"InstanceID\": instanceID,\n\t}}\n\n\teventPayloadAsBytes, err := json.Marshal(eventPayload)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to marshal event payload: %v\", err)\n\t}}\n\n\terr = ctx.GetStub().SetEvent(\"Avtivity_continueDone\", eventPayloadAsBytes)\n\tif err != nil {{\n\t\treturn fmt.Errorf(\"failed to set event: %v\", err)\n\t}}\n\treturn nil\n\n}}",
  "MessageAdvanceFuncFrame": "func (cc *SmartContract) {message}_Advance(\n    ctx contractapi.TransactionContextInterface,\n    instanceID string,\n    targetTaskID string,\n) error {{\n\tstub := ctx.GetStub()\n\tinstance,_ := cc.GetInstance(ctx, instanceID)\n\n\n    collectiveMsgName := \"{message}\"\n\tcollectiveMsg, _ := cc.ReadCollectiveMsg(ctx, instance, collectiveMsgName)\n\t\n\t// MultiTask Address Located\n\tchoreographyTaskID := collectiveMsg.ChoreographyTaskID\n\n\tchoreographyTask, _ := cc.ReadChoreographyTask(ctx, instance, choreographyTaskID)\n\tif choreographyTask.IsMulti == true {{\n\t\tcollectiveMsgName = fmt.Sprintf(\"{message}_%d\", targetTaskID)\n\t}}\n\n    collectiveMsg, _ = cc.ReadCollectiveMsg(ctx, instance, collectiveMsgName)\n\n\tsendParticipantID := collectiveMsg.SendParticipantID\n\treceiveParticipantID := collectiveMsg.ReceiveParticipantID\n\tsendParticipant, _ := cc.ReadCollectiveParticipant(ctx, instance, sendParticipantID)\n\treceiveParticipant, _ := cc.ReadCollectiveParticipant(ctx, instance, receiveParticipantID)\n\n    // Check if Multi \n    if sendParticipant.IsMulti == true && receiveParticipant.IsMulti == true {{\n        return fmt.Errorf(\"Unsupport Operation\")\n    }}\n\n    if sendParticipant.IsMulti == false && receiveParticipant.IsMulti == false {{\n        return fmt.Errorf(\"Not Invalid Operation\")\n    }}\n\n    var participantToLock *CollectiveParticipant\n    if sendParticipant.IsMulti {{\n        // check if invoker in receiveParticipants\n        if cc.check_participant(ctx, instance, receiveParticipantID, \"\") == false {{\n            return fmt.Errorf(\"Not Allowed To Advance\")\n        }}\n        participantToLock = receiveParticipant\n    }}else {{\n        // check if invoker in senderParticipants\n        if cc.check_participant(ctx, instance, sendParticipantID, \"\") == false {{\n            return fmt.Errorf(\"Not Allowd To Advance\")\n        }}\n        participantToLock = sendParticipant\n    }}\n\n    if len(participantToLock.Participants) < participantToLock.MultiMinimum {{\n        errorMessage := fmt.Sprintf(\n            \"Messages count %d does not meet the minimum requirement %d for participant %s\",\n            len(collectiveMsg.Messages),\n            participantToLock.MultiMinimum,\n            participantToLock.ParticipantID,\n        )\n        fmt.Println(errorMessage)\n        return fmt.Errorf(errorMessage)\n    }}\n\n    event := map[string]interface{{}}{{\n        \"type\": \"advance_{message}\",\n    }}\n    eventJsonBytes, _ := json.Marshal(event)\n\n    eventJsonString := string(eventJsonBytes)\n\n    fmt.Println(\"Event\")\n    fmt.Println(eventJsonString)\n    res, err := cc.Invoke_Other_chaincode(ctx, \"StateChartEngine:v1\", \"default\",\n        stateCharts.EncodeExecuteStateMachineArgs(instance.StateMachineDescription, instance.AdditionalContent, instance.CurrentState, eventJsonString))\n    if err != nil {{\n        return fmt.Errorf(\"failed to trigger stateCharts action: %v\", err)\n    }}\n    state, changed := stateCharts.DecodeTriggerActionResult(res)\n\n    fmt.Println(\"State\")\n    fmt.Println(state)\n    fmt.Println(\"Changed\")\n    fmt.Println(changed)\n\n    if !changed {{\n        return fmt.Errorf(\"Invalid Operation\")\n    }}\n    instance.CurrentState = state \n\n    participantToLock.IsLocked = true\n\n    err = cc.SetInstance(ctx, instance)\n    if err != nil {{\n        return fmt.Errorf(\"failed to set instance: %v\", err)\n    }}\n\n    stub.SetEvent(\"Advance{message}\", []byte(\"CollectiveMessage advanced successfully\"))\n    return nil\n}}"
}